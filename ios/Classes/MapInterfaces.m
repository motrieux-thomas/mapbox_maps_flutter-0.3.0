// Autogenerated from Pigeon (v3.2.3), do not edit directly.
// See also: https://pub.dev/packages/pigeon
#import "MapInterfaces.h"
#import <Flutter/Flutter.h>

#if !__has_feature(objc_arc)
#error File requires ARC to be enabled.
#endif

static NSDictionary<NSString *, id> *wrapResult(id result, FlutterError *error) {
  NSDictionary *errorDict = (NSDictionary *)[NSNull null];
  if (error) {
    errorDict = @{
        @"code": (error.code ?: [NSNull null]),
        @"message": (error.message ?: [NSNull null]),
        @"details": (error.details ?: [NSNull null]),
        };
  }
  return @{
      @"result": (result ?: [NSNull null]),
      @"error": errorDict,
      };
}
static id GetNullableObject(NSDictionary* dict, id key) {
  id result = dict[key];
  return (result == [NSNull null]) ? nil : result;
}
static id GetNullableObjectAtIndex(NSArray* array, NSInteger key) {
  id result = array[key];
  return (result == [NSNull null]) ? nil : result;
}


@interface FLTMbxEdgeInsets ()
+ (FLTMbxEdgeInsets *)fromMap:(NSDictionary *)dict;
+ (nullable FLTMbxEdgeInsets *)nullableFromMap:(NSDictionary *)dict;
- (NSDictionary *)toMap;
@end
@interface FLTCameraOptions ()
+ (FLTCameraOptions *)fromMap:(NSDictionary *)dict;
+ (nullable FLTCameraOptions *)nullableFromMap:(NSDictionary *)dict;
- (NSDictionary *)toMap;
@end
@interface FLTCameraState ()
+ (FLTCameraState *)fromMap:(NSDictionary *)dict;
+ (nullable FLTCameraState *)nullableFromMap:(NSDictionary *)dict;
- (NSDictionary *)toMap;
@end
@interface FLTCameraBoundsOptions ()
+ (FLTCameraBoundsOptions *)fromMap:(NSDictionary *)dict;
+ (nullable FLTCameraBoundsOptions *)nullableFromMap:(NSDictionary *)dict;
- (NSDictionary *)toMap;
@end
@interface FLTCameraBounds ()
+ (FLTCameraBounds *)fromMap:(NSDictionary *)dict;
+ (nullable FLTCameraBounds *)nullableFromMap:(NSDictionary *)dict;
- (NSDictionary *)toMap;
@end
@interface FLTMapAnimationOptions ()
+ (FLTMapAnimationOptions *)fromMap:(NSDictionary *)dict;
+ (nullable FLTMapAnimationOptions *)nullableFromMap:(NSDictionary *)dict;
- (NSDictionary *)toMap;
@end
@interface FLTCoordinateBounds ()
+ (FLTCoordinateBounds *)fromMap:(NSDictionary *)dict;
+ (nullable FLTCoordinateBounds *)nullableFromMap:(NSDictionary *)dict;
- (NSDictionary *)toMap;
@end
@interface FLTMapDebugOptions ()
+ (FLTMapDebugOptions *)fromMap:(NSDictionary *)dict;
+ (nullable FLTMapDebugOptions *)nullableFromMap:(NSDictionary *)dict;
- (NSDictionary *)toMap;
@end
@interface FLTGlyphsRasterizationOptions ()
+ (FLTGlyphsRasterizationOptions *)fromMap:(NSDictionary *)dict;
+ (nullable FLTGlyphsRasterizationOptions *)nullableFromMap:(NSDictionary *)dict;
- (NSDictionary *)toMap;
@end
@interface FLTMapMemoryBudgetInMegabytes ()
+ (FLTMapMemoryBudgetInMegabytes *)fromMap:(NSDictionary *)dict;
+ (nullable FLTMapMemoryBudgetInMegabytes *)nullableFromMap:(NSDictionary *)dict;
- (NSDictionary *)toMap;
@end
@interface FLTMapMemoryBudgetInTiles ()
+ (FLTMapMemoryBudgetInTiles *)fromMap:(NSDictionary *)dict;
+ (nullable FLTMapMemoryBudgetInTiles *)nullableFromMap:(NSDictionary *)dict;
- (NSDictionary *)toMap;
@end
@interface FLTMapOptions ()
+ (FLTMapOptions *)fromMap:(NSDictionary *)dict;
+ (nullable FLTMapOptions *)nullableFromMap:(NSDictionary *)dict;
- (NSDictionary *)toMap;
@end
@interface FLTScreenCoordinate ()
+ (FLTScreenCoordinate *)fromMap:(NSDictionary *)dict;
+ (nullable FLTScreenCoordinate *)nullableFromMap:(NSDictionary *)dict;
- (NSDictionary *)toMap;
@end
@interface FLTScreenBox ()
+ (FLTScreenBox *)fromMap:(NSDictionary *)dict;
+ (nullable FLTScreenBox *)nullableFromMap:(NSDictionary *)dict;
- (NSDictionary *)toMap;
@end
@interface FLTCoordinateBoundsZoom ()
+ (FLTCoordinateBoundsZoom *)fromMap:(NSDictionary *)dict;
+ (nullable FLTCoordinateBoundsZoom *)nullableFromMap:(NSDictionary *)dict;
- (NSDictionary *)toMap;
@end
@interface FLTSize ()
+ (FLTSize *)fromMap:(NSDictionary *)dict;
+ (nullable FLTSize *)nullableFromMap:(NSDictionary *)dict;
- (NSDictionary *)toMap;
@end
@interface FLTRenderedQueryOptions ()
+ (FLTRenderedQueryOptions *)fromMap:(NSDictionary *)dict;
+ (nullable FLTRenderedQueryOptions *)nullableFromMap:(NSDictionary *)dict;
- (NSDictionary *)toMap;
@end
@interface FLTSourceQueryOptions ()
+ (FLTSourceQueryOptions *)fromMap:(NSDictionary *)dict;
+ (nullable FLTSourceQueryOptions *)nullableFromMap:(NSDictionary *)dict;
- (NSDictionary *)toMap;
@end
@interface FLTFeatureExtensionValue ()
+ (FLTFeatureExtensionValue *)fromMap:(NSDictionary *)dict;
+ (nullable FLTFeatureExtensionValue *)nullableFromMap:(NSDictionary *)dict;
- (NSDictionary *)toMap;
@end
@interface FLTLayerPosition ()
+ (FLTLayerPosition *)fromMap:(NSDictionary *)dict;
+ (nullable FLTLayerPosition *)nullableFromMap:(NSDictionary *)dict;
- (NSDictionary *)toMap;
@end
@interface FLTQueriedFeature ()
+ (FLTQueriedFeature *)fromMap:(NSDictionary *)dict;
+ (nullable FLTQueriedFeature *)nullableFromMap:(NSDictionary *)dict;
- (NSDictionary *)toMap;
@end
@interface FLTRenderedQueryGeometry ()
+ (FLTRenderedQueryGeometry *)fromMap:(NSDictionary *)dict;
+ (nullable FLTRenderedQueryGeometry *)nullableFromMap:(NSDictionary *)dict;
- (NSDictionary *)toMap;
@end
@interface FLTOfflineRegionGeometryDefinition ()
+ (FLTOfflineRegionGeometryDefinition *)fromMap:(NSDictionary *)dict;
+ (nullable FLTOfflineRegionGeometryDefinition *)nullableFromMap:(NSDictionary *)dict;
- (NSDictionary *)toMap;
@end
@interface FLTOfflineRegionTilePyramidDefinition ()
+ (FLTOfflineRegionTilePyramidDefinition *)fromMap:(NSDictionary *)dict;
+ (nullable FLTOfflineRegionTilePyramidDefinition *)nullableFromMap:(NSDictionary *)dict;
- (NSDictionary *)toMap;
@end
@interface FLTProjectedMeters ()
+ (FLTProjectedMeters *)fromMap:(NSDictionary *)dict;
+ (nullable FLTProjectedMeters *)nullableFromMap:(NSDictionary *)dict;
- (NSDictionary *)toMap;
@end
@interface FLTMercatorCoordinate ()
+ (FLTMercatorCoordinate *)fromMap:(NSDictionary *)dict;
+ (nullable FLTMercatorCoordinate *)nullableFromMap:(NSDictionary *)dict;
- (NSDictionary *)toMap;
@end
@interface FLTResourceOptions ()
+ (FLTResourceOptions *)fromMap:(NSDictionary *)dict;
+ (nullable FLTResourceOptions *)nullableFromMap:(NSDictionary *)dict;
- (NSDictionary *)toMap;
@end
@interface FLTStyleObjectInfo ()
+ (FLTStyleObjectInfo *)fromMap:(NSDictionary *)dict;
+ (nullable FLTStyleObjectInfo *)nullableFromMap:(NSDictionary *)dict;
- (NSDictionary *)toMap;
@end
@interface FLTMbxImage ()
+ (FLTMbxImage *)fromMap:(NSDictionary *)dict;
+ (nullable FLTMbxImage *)nullableFromMap:(NSDictionary *)dict;
- (NSDictionary *)toMap;
@end
@interface FLTImageStretches ()
+ (FLTImageStretches *)fromMap:(NSDictionary *)dict;
+ (nullable FLTImageStretches *)nullableFromMap:(NSDictionary *)dict;
- (NSDictionary *)toMap;
@end
@interface FLTImageContent ()
+ (FLTImageContent *)fromMap:(NSDictionary *)dict;
+ (nullable FLTImageContent *)nullableFromMap:(NSDictionary *)dict;
- (NSDictionary *)toMap;
@end
@interface FLTTransitionOptions ()
+ (FLTTransitionOptions *)fromMap:(NSDictionary *)dict;
+ (nullable FLTTransitionOptions *)nullableFromMap:(NSDictionary *)dict;
- (NSDictionary *)toMap;
@end
@interface FLTCanonicalTileID ()
+ (FLTCanonicalTileID *)fromMap:(NSDictionary *)dict;
+ (nullable FLTCanonicalTileID *)nullableFromMap:(NSDictionary *)dict;
- (NSDictionary *)toMap;
@end
@interface FLTStylePropertyValue ()
+ (FLTStylePropertyValue *)fromMap:(NSDictionary *)dict;
+ (nullable FLTStylePropertyValue *)nullableFromMap:(NSDictionary *)dict;
- (NSDictionary *)toMap;
@end

@implementation FLTMbxEdgeInsets
+ (instancetype)makeWithTop:(NSNumber *)top
    left:(NSNumber *)left
    bottom:(NSNumber *)bottom
    right:(NSNumber *)right {
  FLTMbxEdgeInsets* pigeonResult = [[FLTMbxEdgeInsets alloc] init];
  pigeonResult.top = top;
  pigeonResult.left = left;
  pigeonResult.bottom = bottom;
  pigeonResult.right = right;
  return pigeonResult;
}
+ (FLTMbxEdgeInsets *)fromMap:(NSDictionary *)dict {
  FLTMbxEdgeInsets *pigeonResult = [[FLTMbxEdgeInsets alloc] init];
  pigeonResult.top = GetNullableObject(dict, @"top");
  NSAssert(pigeonResult.top != nil, @"");
  pigeonResult.left = GetNullableObject(dict, @"left");
  NSAssert(pigeonResult.left != nil, @"");
  pigeonResult.bottom = GetNullableObject(dict, @"bottom");
  NSAssert(pigeonResult.bottom != nil, @"");
  pigeonResult.right = GetNullableObject(dict, @"right");
  NSAssert(pigeonResult.right != nil, @"");
  return pigeonResult;
}
+ (nullable FLTMbxEdgeInsets *)nullableFromMap:(NSDictionary *)dict { return (dict) ? [FLTMbxEdgeInsets fromMap:dict] : nil; }
- (NSDictionary *)toMap {
  return @{
    @"top" : (self.top ?: [NSNull null]),
    @"left" : (self.left ?: [NSNull null]),
    @"bottom" : (self.bottom ?: [NSNull null]),
    @"right" : (self.right ?: [NSNull null]),
  };
}
@end

@implementation FLTCameraOptions
+ (instancetype)makeWithCenter:(nullable NSDictionary<NSString *, id> *)center
    padding:(nullable FLTMbxEdgeInsets *)padding
    anchor:(nullable FLTScreenCoordinate *)anchor
    zoom:(nullable NSNumber *)zoom
    bearing:(nullable NSNumber *)bearing
    pitch:(nullable NSNumber *)pitch {
  FLTCameraOptions* pigeonResult = [[FLTCameraOptions alloc] init];
  pigeonResult.center = center;
  pigeonResult.padding = padding;
  pigeonResult.anchor = anchor;
  pigeonResult.zoom = zoom;
  pigeonResult.bearing = bearing;
  pigeonResult.pitch = pitch;
  return pigeonResult;
}
+ (FLTCameraOptions *)fromMap:(NSDictionary *)dict {
  FLTCameraOptions *pigeonResult = [[FLTCameraOptions alloc] init];
  pigeonResult.center = GetNullableObject(dict, @"center");
  pigeonResult.padding = [FLTMbxEdgeInsets nullableFromMap:GetNullableObject(dict, @"padding")];
  pigeonResult.anchor = [FLTScreenCoordinate nullableFromMap:GetNullableObject(dict, @"anchor")];
  pigeonResult.zoom = GetNullableObject(dict, @"zoom");
  pigeonResult.bearing = GetNullableObject(dict, @"bearing");
  pigeonResult.pitch = GetNullableObject(dict, @"pitch");
  return pigeonResult;
}
+ (nullable FLTCameraOptions *)nullableFromMap:(NSDictionary *)dict { return (dict) ? [FLTCameraOptions fromMap:dict] : nil; }
- (NSDictionary *)toMap {
  return @{
    @"center" : (self.center ?: [NSNull null]),
    @"padding" : (self.padding ? [self.padding toMap] : [NSNull null]),
    @"anchor" : (self.anchor ? [self.anchor toMap] : [NSNull null]),
    @"zoom" : (self.zoom ?: [NSNull null]),
    @"bearing" : (self.bearing ?: [NSNull null]),
    @"pitch" : (self.pitch ?: [NSNull null]),
  };
}
@end

@implementation FLTCameraState
+ (instancetype)makeWithCenter:(NSDictionary<NSString *, id> *)center
    padding:(FLTMbxEdgeInsets *)padding
    zoom:(NSNumber *)zoom
    bearing:(NSNumber *)bearing
    pitch:(NSNumber *)pitch {
  FLTCameraState* pigeonResult = [[FLTCameraState alloc] init];
  pigeonResult.center = center;
  pigeonResult.padding = padding;
  pigeonResult.zoom = zoom;
  pigeonResult.bearing = bearing;
  pigeonResult.pitch = pitch;
  return pigeonResult;
}
+ (FLTCameraState *)fromMap:(NSDictionary *)dict {
  FLTCameraState *pigeonResult = [[FLTCameraState alloc] init];
  pigeonResult.center = GetNullableObject(dict, @"center");
  NSAssert(pigeonResult.center != nil, @"");
  pigeonResult.padding = [FLTMbxEdgeInsets nullableFromMap:GetNullableObject(dict, @"padding")];
  NSAssert(pigeonResult.padding != nil, @"");
  pigeonResult.zoom = GetNullableObject(dict, @"zoom");
  NSAssert(pigeonResult.zoom != nil, @"");
  pigeonResult.bearing = GetNullableObject(dict, @"bearing");
  NSAssert(pigeonResult.bearing != nil, @"");
  pigeonResult.pitch = GetNullableObject(dict, @"pitch");
  NSAssert(pigeonResult.pitch != nil, @"");
  return pigeonResult;
}
+ (nullable FLTCameraState *)nullableFromMap:(NSDictionary *)dict { return (dict) ? [FLTCameraState fromMap:dict] : nil; }
- (NSDictionary *)toMap {
  return @{
    @"center" : (self.center ?: [NSNull null]),
    @"padding" : (self.padding ? [self.padding toMap] : [NSNull null]),
    @"zoom" : (self.zoom ?: [NSNull null]),
    @"bearing" : (self.bearing ?: [NSNull null]),
    @"pitch" : (self.pitch ?: [NSNull null]),
  };
}
@end

@implementation FLTCameraBoundsOptions
+ (instancetype)makeWithBounds:(nullable FLTCoordinateBounds *)bounds
    maxZoom:(nullable NSNumber *)maxZoom
    minZoom:(nullable NSNumber *)minZoom
    maxPitch:(nullable NSNumber *)maxPitch
    minPitch:(nullable NSNumber *)minPitch {
  FLTCameraBoundsOptions* pigeonResult = [[FLTCameraBoundsOptions alloc] init];
  pigeonResult.bounds = bounds;
  pigeonResult.maxZoom = maxZoom;
  pigeonResult.minZoom = minZoom;
  pigeonResult.maxPitch = maxPitch;
  pigeonResult.minPitch = minPitch;
  return pigeonResult;
}
+ (FLTCameraBoundsOptions *)fromMap:(NSDictionary *)dict {
  FLTCameraBoundsOptions *pigeonResult = [[FLTCameraBoundsOptions alloc] init];
  pigeonResult.bounds = [FLTCoordinateBounds nullableFromMap:GetNullableObject(dict, @"bounds")];
  pigeonResult.maxZoom = GetNullableObject(dict, @"maxZoom");
  pigeonResult.minZoom = GetNullableObject(dict, @"minZoom");
  pigeonResult.maxPitch = GetNullableObject(dict, @"maxPitch");
  pigeonResult.minPitch = GetNullableObject(dict, @"minPitch");
  return pigeonResult;
}
+ (nullable FLTCameraBoundsOptions *)nullableFromMap:(NSDictionary *)dict { return (dict) ? [FLTCameraBoundsOptions fromMap:dict] : nil; }
- (NSDictionary *)toMap {
  return @{
    @"bounds" : (self.bounds ? [self.bounds toMap] : [NSNull null]),
    @"maxZoom" : (self.maxZoom ?: [NSNull null]),
    @"minZoom" : (self.minZoom ?: [NSNull null]),
    @"maxPitch" : (self.maxPitch ?: [NSNull null]),
    @"minPitch" : (self.minPitch ?: [NSNull null]),
  };
}
@end

@implementation FLTCameraBounds
+ (instancetype)makeWithBounds:(FLTCoordinateBounds *)bounds
    maxZoom:(NSNumber *)maxZoom
    minZoom:(NSNumber *)minZoom
    maxPitch:(NSNumber *)maxPitch
    minPitch:(NSNumber *)minPitch {
  FLTCameraBounds* pigeonResult = [[FLTCameraBounds alloc] init];
  pigeonResult.bounds = bounds;
  pigeonResult.maxZoom = maxZoom;
  pigeonResult.minZoom = minZoom;
  pigeonResult.maxPitch = maxPitch;
  pigeonResult.minPitch = minPitch;
  return pigeonResult;
}
+ (FLTCameraBounds *)fromMap:(NSDictionary *)dict {
  FLTCameraBounds *pigeonResult = [[FLTCameraBounds alloc] init];
  pigeonResult.bounds = [FLTCoordinateBounds nullableFromMap:GetNullableObject(dict, @"bounds")];
  NSAssert(pigeonResult.bounds != nil, @"");
  pigeonResult.maxZoom = GetNullableObject(dict, @"maxZoom");
  NSAssert(pigeonResult.maxZoom != nil, @"");
  pigeonResult.minZoom = GetNullableObject(dict, @"minZoom");
  NSAssert(pigeonResult.minZoom != nil, @"");
  pigeonResult.maxPitch = GetNullableObject(dict, @"maxPitch");
  NSAssert(pigeonResult.maxPitch != nil, @"");
  pigeonResult.minPitch = GetNullableObject(dict, @"minPitch");
  NSAssert(pigeonResult.minPitch != nil, @"");
  return pigeonResult;
}
+ (nullable FLTCameraBounds *)nullableFromMap:(NSDictionary *)dict { return (dict) ? [FLTCameraBounds fromMap:dict] : nil; }
- (NSDictionary *)toMap {
  return @{
    @"bounds" : (self.bounds ? [self.bounds toMap] : [NSNull null]),
    @"maxZoom" : (self.maxZoom ?: [NSNull null]),
    @"minZoom" : (self.minZoom ?: [NSNull null]),
    @"maxPitch" : (self.maxPitch ?: [NSNull null]),
    @"minPitch" : (self.minPitch ?: [NSNull null]),
  };
}
@end

@implementation FLTMapAnimationOptions
+ (instancetype)makeWithDuration:(nullable NSNumber *)duration
    startDelay:(nullable NSNumber *)startDelay {
  FLTMapAnimationOptions* pigeonResult = [[FLTMapAnimationOptions alloc] init];
  pigeonResult.duration = duration;
  pigeonResult.startDelay = startDelay;
  return pigeonResult;
}
+ (FLTMapAnimationOptions *)fromMap:(NSDictionary *)dict {
  FLTMapAnimationOptions *pigeonResult = [[FLTMapAnimationOptions alloc] init];
  pigeonResult.duration = GetNullableObject(dict, @"duration");
  pigeonResult.startDelay = GetNullableObject(dict, @"startDelay");
  return pigeonResult;
}
+ (nullable FLTMapAnimationOptions *)nullableFromMap:(NSDictionary *)dict { return (dict) ? [FLTMapAnimationOptions fromMap:dict] : nil; }
- (NSDictionary *)toMap {
  return @{
    @"duration" : (self.duration ?: [NSNull null]),
    @"startDelay" : (self.startDelay ?: [NSNull null]),
  };
}
@end

@implementation FLTCoordinateBounds
+ (instancetype)makeWithSouthwest:(NSDictionary<NSString *, id> *)southwest
    northeast:(NSDictionary<NSString *, id> *)northeast
    infiniteBounds:(NSNumber *)infiniteBounds {
  FLTCoordinateBounds* pigeonResult = [[FLTCoordinateBounds alloc] init];
  pigeonResult.southwest = southwest;
  pigeonResult.northeast = northeast;
  pigeonResult.infiniteBounds = infiniteBounds;
  return pigeonResult;
}
+ (FLTCoordinateBounds *)fromMap:(NSDictionary *)dict {
  FLTCoordinateBounds *pigeonResult = [[FLTCoordinateBounds alloc] init];
  pigeonResult.southwest = GetNullableObject(dict, @"southwest");
  NSAssert(pigeonResult.southwest != nil, @"");
  pigeonResult.northeast = GetNullableObject(dict, @"northeast");
  NSAssert(pigeonResult.northeast != nil, @"");
  pigeonResult.infiniteBounds = GetNullableObject(dict, @"infiniteBounds");
  NSAssert(pigeonResult.infiniteBounds != nil, @"");
  return pigeonResult;
}
+ (nullable FLTCoordinateBounds *)nullableFromMap:(NSDictionary *)dict { return (dict) ? [FLTCoordinateBounds fromMap:dict] : nil; }
- (NSDictionary *)toMap {
  return @{
    @"southwest" : (self.southwest ?: [NSNull null]),
    @"northeast" : (self.northeast ?: [NSNull null]),
    @"infiniteBounds" : (self.infiniteBounds ?: [NSNull null]),
  };
}
@end

@implementation FLTMapDebugOptions
+ (instancetype)makeWithData:(FLTMapDebugOptionsData)data {
  FLTMapDebugOptions* pigeonResult = [[FLTMapDebugOptions alloc] init];
  pigeonResult.data = data;
  return pigeonResult;
}
+ (FLTMapDebugOptions *)fromMap:(NSDictionary *)dict {
  FLTMapDebugOptions *pigeonResult = [[FLTMapDebugOptions alloc] init];
  pigeonResult.data = [GetNullableObject(dict, @"data") integerValue];
  return pigeonResult;
}
+ (nullable FLTMapDebugOptions *)nullableFromMap:(NSDictionary *)dict { return (dict) ? [FLTMapDebugOptions fromMap:dict] : nil; }
- (NSDictionary *)toMap {
  return @{
    @"data" : @(self.data),
  };
}
@end

@implementation FLTGlyphsRasterizationOptions
+ (instancetype)makeWithRasterizationMode:(FLTGlyphsRasterizationMode)rasterizationMode
    fontFamily:(nullable NSString *)fontFamily {
  FLTGlyphsRasterizationOptions* pigeonResult = [[FLTGlyphsRasterizationOptions alloc] init];
  pigeonResult.rasterizationMode = rasterizationMode;
  pigeonResult.fontFamily = fontFamily;
  return pigeonResult;
}
+ (FLTGlyphsRasterizationOptions *)fromMap:(NSDictionary *)dict {
  FLTGlyphsRasterizationOptions *pigeonResult = [[FLTGlyphsRasterizationOptions alloc] init];
  pigeonResult.rasterizationMode = [GetNullableObject(dict, @"rasterizationMode") integerValue];
  pigeonResult.fontFamily = GetNullableObject(dict, @"fontFamily");
  return pigeonResult;
}
+ (nullable FLTGlyphsRasterizationOptions *)nullableFromMap:(NSDictionary *)dict { return (dict) ? [FLTGlyphsRasterizationOptions fromMap:dict] : nil; }
- (NSDictionary *)toMap {
  return @{
    @"rasterizationMode" : @(self.rasterizationMode),
    @"fontFamily" : (self.fontFamily ?: [NSNull null]),
  };
}
@end

@implementation FLTMapMemoryBudgetInMegabytes
+ (instancetype)makeWithSize:(NSNumber *)size {
  FLTMapMemoryBudgetInMegabytes* pigeonResult = [[FLTMapMemoryBudgetInMegabytes alloc] init];
  pigeonResult.size = size;
  return pigeonResult;
}
+ (FLTMapMemoryBudgetInMegabytes *)fromMap:(NSDictionary *)dict {
  FLTMapMemoryBudgetInMegabytes *pigeonResult = [[FLTMapMemoryBudgetInMegabytes alloc] init];
  pigeonResult.size = GetNullableObject(dict, @"size");
  NSAssert(pigeonResult.size != nil, @"");
  return pigeonResult;
}
+ (nullable FLTMapMemoryBudgetInMegabytes *)nullableFromMap:(NSDictionary *)dict { return (dict) ? [FLTMapMemoryBudgetInMegabytes fromMap:dict] : nil; }
- (NSDictionary *)toMap {
  return @{
    @"size" : (self.size ?: [NSNull null]),
  };
}
@end

@implementation FLTMapMemoryBudgetInTiles
+ (instancetype)makeWithSize:(NSNumber *)size {
  FLTMapMemoryBudgetInTiles* pigeonResult = [[FLTMapMemoryBudgetInTiles alloc] init];
  pigeonResult.size = size;
  return pigeonResult;
}
+ (FLTMapMemoryBudgetInTiles *)fromMap:(NSDictionary *)dict {
  FLTMapMemoryBudgetInTiles *pigeonResult = [[FLTMapMemoryBudgetInTiles alloc] init];
  pigeonResult.size = GetNullableObject(dict, @"size");
  NSAssert(pigeonResult.size != nil, @"");
  return pigeonResult;
}
+ (nullable FLTMapMemoryBudgetInTiles *)nullableFromMap:(NSDictionary *)dict { return (dict) ? [FLTMapMemoryBudgetInTiles fromMap:dict] : nil; }
- (NSDictionary *)toMap {
  return @{
    @"size" : (self.size ?: [NSNull null]),
  };
}
@end

@implementation FLTMapOptions
+ (instancetype)makeWithContextMode:(FLTContextMode)contextMode
    constrainMode:(FLTConstrainMode)constrainMode
    viewportMode:(FLTViewportMode)viewportMode
    orientation:(FLTNorthOrientation)orientation
    crossSourceCollisions:(nullable NSNumber *)crossSourceCollisions
    optimizeForTerrain:(nullable NSNumber *)optimizeForTerrain
    size:(nullable FLTSize *)size
    pixelRatio:(NSNumber *)pixelRatio
    glyphsRasterizationOptions:(nullable FLTGlyphsRasterizationOptions *)glyphsRasterizationOptions {
  FLTMapOptions* pigeonResult = [[FLTMapOptions alloc] init];
  pigeonResult.contextMode = contextMode;
  pigeonResult.constrainMode = constrainMode;
  pigeonResult.viewportMode = viewportMode;
  pigeonResult.orientation = orientation;
  pigeonResult.crossSourceCollisions = crossSourceCollisions;
  pigeonResult.optimizeForTerrain = optimizeForTerrain;
  pigeonResult.size = size;
  pigeonResult.pixelRatio = pixelRatio;
  pigeonResult.glyphsRasterizationOptions = glyphsRasterizationOptions;
  return pigeonResult;
}
+ (FLTMapOptions *)fromMap:(NSDictionary *)dict {
  FLTMapOptions *pigeonResult = [[FLTMapOptions alloc] init];
  pigeonResult.contextMode = [GetNullableObject(dict, @"contextMode") integerValue];
  pigeonResult.constrainMode = [GetNullableObject(dict, @"constrainMode") integerValue];
  pigeonResult.viewportMode = [GetNullableObject(dict, @"viewportMode") integerValue];
  pigeonResult.orientation = [GetNullableObject(dict, @"orientation") integerValue];
  pigeonResult.crossSourceCollisions = GetNullableObject(dict, @"crossSourceCollisions");
  pigeonResult.optimizeForTerrain = GetNullableObject(dict, @"optimizeForTerrain");
  pigeonResult.size = [FLTSize nullableFromMap:GetNullableObject(dict, @"size")];
  pigeonResult.pixelRatio = GetNullableObject(dict, @"pixelRatio");
  NSAssert(pigeonResult.pixelRatio != nil, @"");
  pigeonResult.glyphsRasterizationOptions = [FLTGlyphsRasterizationOptions nullableFromMap:GetNullableObject(dict, @"glyphsRasterizationOptions")];
  return pigeonResult;
}
+ (nullable FLTMapOptions *)nullableFromMap:(NSDictionary *)dict { return (dict) ? [FLTMapOptions fromMap:dict] : nil; }
- (NSDictionary *)toMap {
  return @{
    @"contextMode" : @(self.contextMode),
    @"constrainMode" : @(self.constrainMode),
    @"viewportMode" : @(self.viewportMode),
    @"orientation" : @(self.orientation),
    @"crossSourceCollisions" : (self.crossSourceCollisions ?: [NSNull null]),
    @"optimizeForTerrain" : (self.optimizeForTerrain ?: [NSNull null]),
    @"size" : (self.size ? [self.size toMap] : [NSNull null]),
    @"pixelRatio" : (self.pixelRatio ?: [NSNull null]),
    @"glyphsRasterizationOptions" : (self.glyphsRasterizationOptions ? [self.glyphsRasterizationOptions toMap] : [NSNull null]),
  };
}
@end

@implementation FLTScreenCoordinate
+ (instancetype)makeWithX:(NSNumber *)x
    y:(NSNumber *)y {
  FLTScreenCoordinate* pigeonResult = [[FLTScreenCoordinate alloc] init];
  pigeonResult.x = x;
  pigeonResult.y = y;
  return pigeonResult;
}
+ (FLTScreenCoordinate *)fromMap:(NSDictionary *)dict {
  FLTScreenCoordinate *pigeonResult = [[FLTScreenCoordinate alloc] init];
  pigeonResult.x = GetNullableObject(dict, @"x");
  NSAssert(pigeonResult.x != nil, @"");
  pigeonResult.y = GetNullableObject(dict, @"y");
  NSAssert(pigeonResult.y != nil, @"");
  return pigeonResult;
}
+ (nullable FLTScreenCoordinate *)nullableFromMap:(NSDictionary *)dict { return (dict) ? [FLTScreenCoordinate fromMap:dict] : nil; }
- (NSDictionary *)toMap {
  return @{
    @"x" : (self.x ?: [NSNull null]),
    @"y" : (self.y ?: [NSNull null]),
  };
}
@end

@implementation FLTScreenBox
+ (instancetype)makeWithMin:(FLTScreenCoordinate *)min
    max:(FLTScreenCoordinate *)max {
  FLTScreenBox* pigeonResult = [[FLTScreenBox alloc] init];
  pigeonResult.min = min;
  pigeonResult.max = max;
  return pigeonResult;
}
+ (FLTScreenBox *)fromMap:(NSDictionary *)dict {
  FLTScreenBox *pigeonResult = [[FLTScreenBox alloc] init];
  pigeonResult.min = [FLTScreenCoordinate nullableFromMap:GetNullableObject(dict, @"min")];
  NSAssert(pigeonResult.min != nil, @"");
  pigeonResult.max = [FLTScreenCoordinate nullableFromMap:GetNullableObject(dict, @"max")];
  NSAssert(pigeonResult.max != nil, @"");
  return pigeonResult;
}
+ (nullable FLTScreenBox *)nullableFromMap:(NSDictionary *)dict { return (dict) ? [FLTScreenBox fromMap:dict] : nil; }
- (NSDictionary *)toMap {
  return @{
    @"min" : (self.min ? [self.min toMap] : [NSNull null]),
    @"max" : (self.max ? [self.max toMap] : [NSNull null]),
  };
}
@end

@implementation FLTCoordinateBoundsZoom
+ (instancetype)makeWithBounds:(FLTCoordinateBounds *)bounds
    zoom:(NSNumber *)zoom {
  FLTCoordinateBoundsZoom* pigeonResult = [[FLTCoordinateBoundsZoom alloc] init];
  pigeonResult.bounds = bounds;
  pigeonResult.zoom = zoom;
  return pigeonResult;
}
+ (FLTCoordinateBoundsZoom *)fromMap:(NSDictionary *)dict {
  FLTCoordinateBoundsZoom *pigeonResult = [[FLTCoordinateBoundsZoom alloc] init];
  pigeonResult.bounds = [FLTCoordinateBounds nullableFromMap:GetNullableObject(dict, @"bounds")];
  NSAssert(pigeonResult.bounds != nil, @"");
  pigeonResult.zoom = GetNullableObject(dict, @"zoom");
  NSAssert(pigeonResult.zoom != nil, @"");
  return pigeonResult;
}
+ (nullable FLTCoordinateBoundsZoom *)nullableFromMap:(NSDictionary *)dict { return (dict) ? [FLTCoordinateBoundsZoom fromMap:dict] : nil; }
- (NSDictionary *)toMap {
  return @{
    @"bounds" : (self.bounds ? [self.bounds toMap] : [NSNull null]),
    @"zoom" : (self.zoom ?: [NSNull null]),
  };
}
@end

@implementation FLTSize
+ (instancetype)makeWithWidth:(NSNumber *)width
    height:(NSNumber *)height {
  FLTSize* pigeonResult = [[FLTSize alloc] init];
  pigeonResult.width = width;
  pigeonResult.height = height;
  return pigeonResult;
}
+ (FLTSize *)fromMap:(NSDictionary *)dict {
  FLTSize *pigeonResult = [[FLTSize alloc] init];
  pigeonResult.width = GetNullableObject(dict, @"width");
  NSAssert(pigeonResult.width != nil, @"");
  pigeonResult.height = GetNullableObject(dict, @"height");
  NSAssert(pigeonResult.height != nil, @"");
  return pigeonResult;
}
+ (nullable FLTSize *)nullableFromMap:(NSDictionary *)dict { return (dict) ? [FLTSize fromMap:dict] : nil; }
- (NSDictionary *)toMap {
  return @{
    @"width" : (self.width ?: [NSNull null]),
    @"height" : (self.height ?: [NSNull null]),
  };
}
@end

@implementation FLTRenderedQueryOptions
+ (instancetype)makeWithLayerIds:(nullable NSArray<NSString *> *)layerIds
    filter:(nullable NSString *)filter {
  FLTRenderedQueryOptions* pigeonResult = [[FLTRenderedQueryOptions alloc] init];
  pigeonResult.layerIds = layerIds;
  pigeonResult.filter = filter;
  return pigeonResult;
}
+ (FLTRenderedQueryOptions *)fromMap:(NSDictionary *)dict {
  FLTRenderedQueryOptions *pigeonResult = [[FLTRenderedQueryOptions alloc] init];
  pigeonResult.layerIds = GetNullableObject(dict, @"layerIds");
  pigeonResult.filter = GetNullableObject(dict, @"filter");
  return pigeonResult;
}
+ (nullable FLTRenderedQueryOptions *)nullableFromMap:(NSDictionary *)dict { return (dict) ? [FLTRenderedQueryOptions fromMap:dict] : nil; }
- (NSDictionary *)toMap {
  return @{
    @"layerIds" : (self.layerIds ?: [NSNull null]),
    @"filter" : (self.filter ?: [NSNull null]),
  };
}
@end

@implementation FLTSourceQueryOptions
+ (instancetype)makeWithSourceLayerIds:(nullable NSArray<NSString *> *)sourceLayerIds
    filter:(NSString *)filter {
  FLTSourceQueryOptions* pigeonResult = [[FLTSourceQueryOptions alloc] init];
  pigeonResult.sourceLayerIds = sourceLayerIds;
  pigeonResult.filter = filter;
  return pigeonResult;
}
+ (FLTSourceQueryOptions *)fromMap:(NSDictionary *)dict {
  FLTSourceQueryOptions *pigeonResult = [[FLTSourceQueryOptions alloc] init];
  pigeonResult.sourceLayerIds = GetNullableObject(dict, @"sourceLayerIds");
  pigeonResult.filter = GetNullableObject(dict, @"filter");
  NSAssert(pigeonResult.filter != nil, @"");
  return pigeonResult;
}
+ (nullable FLTSourceQueryOptions *)nullableFromMap:(NSDictionary *)dict { return (dict) ? [FLTSourceQueryOptions fromMap:dict] : nil; }
- (NSDictionary *)toMap {
  return @{
    @"sourceLayerIds" : (self.sourceLayerIds ?: [NSNull null]),
    @"filter" : (self.filter ?: [NSNull null]),
  };
}
@end

@implementation FLTFeatureExtensionValue
+ (instancetype)makeWithValue:(nullable NSString *)value
    featureCollection:(nullable NSArray<NSDictionary<NSString *, id> *> *)featureCollection {
  FLTFeatureExtensionValue* pigeonResult = [[FLTFeatureExtensionValue alloc] init];
  pigeonResult.value = value;
  pigeonResult.featureCollection = featureCollection;
  return pigeonResult;
}
+ (FLTFeatureExtensionValue *)fromMap:(NSDictionary *)dict {
  FLTFeatureExtensionValue *pigeonResult = [[FLTFeatureExtensionValue alloc] init];
  pigeonResult.value = GetNullableObject(dict, @"value");
  pigeonResult.featureCollection = GetNullableObject(dict, @"featureCollection");
  return pigeonResult;
}
+ (nullable FLTFeatureExtensionValue *)nullableFromMap:(NSDictionary *)dict { return (dict) ? [FLTFeatureExtensionValue fromMap:dict] : nil; }
- (NSDictionary *)toMap {
  return @{
    @"value" : (self.value ?: [NSNull null]),
    @"featureCollection" : (self.featureCollection ?: [NSNull null]),
  };
}
@end

@implementation FLTLayerPosition
+ (instancetype)makeWithAbove:(nullable NSString *)above
    below:(nullable NSString *)below
    at:(nullable NSNumber *)at {
  FLTLayerPosition* pigeonResult = [[FLTLayerPosition alloc] init];
  pigeonResult.above = above;
  pigeonResult.below = below;
  pigeonResult.at = at;
  return pigeonResult;
}
+ (FLTLayerPosition *)fromMap:(NSDictionary *)dict {
  FLTLayerPosition *pigeonResult = [[FLTLayerPosition alloc] init];
  pigeonResult.above = GetNullableObject(dict, @"above");
  pigeonResult.below = GetNullableObject(dict, @"below");
  pigeonResult.at = GetNullableObject(dict, @"at");
  return pigeonResult;
}
+ (nullable FLTLayerPosition *)nullableFromMap:(NSDictionary *)dict { return (dict) ? [FLTLayerPosition fromMap:dict] : nil; }
- (NSDictionary *)toMap {
  return @{
    @"above" : (self.above ?: [NSNull null]),
    @"below" : (self.below ?: [NSNull null]),
    @"at" : (self.at ?: [NSNull null]),
  };
}
@end

@implementation FLTQueriedFeature
+ (instancetype)makeWithFeature:(NSDictionary<NSString *, id> *)feature
    source:(NSString *)source
    sourceLayer:(nullable NSString *)sourceLayer
    state:(NSString *)state {
  FLTQueriedFeature* pigeonResult = [[FLTQueriedFeature alloc] init];
  pigeonResult.feature = feature;
  pigeonResult.source = source;
  pigeonResult.sourceLayer = sourceLayer;
  pigeonResult.state = state;
  return pigeonResult;
}
+ (FLTQueriedFeature *)fromMap:(NSDictionary *)dict {
  FLTQueriedFeature *pigeonResult = [[FLTQueriedFeature alloc] init];
  pigeonResult.feature = GetNullableObject(dict, @"feature");
  NSAssert(pigeonResult.feature != nil, @"");
  pigeonResult.source = GetNullableObject(dict, @"source");
  NSAssert(pigeonResult.source != nil, @"");
  pigeonResult.sourceLayer = GetNullableObject(dict, @"sourceLayer");
  pigeonResult.state = GetNullableObject(dict, @"state");
  NSAssert(pigeonResult.state != nil, @"");
  return pigeonResult;
}
+ (nullable FLTQueriedFeature *)nullableFromMap:(NSDictionary *)dict { return (dict) ? [FLTQueriedFeature fromMap:dict] : nil; }
- (NSDictionary *)toMap {
  return @{
    @"feature" : (self.feature ?: [NSNull null]),
    @"source" : (self.source ?: [NSNull null]),
    @"sourceLayer" : (self.sourceLayer ?: [NSNull null]),
    @"state" : (self.state ?: [NSNull null]),
  };
}
@end

@implementation FLTRenderedQueryGeometry
+ (instancetype)makeWithValue:(NSString *)value
    type:(FLTType)type {
  FLTRenderedQueryGeometry* pigeonResult = [[FLTRenderedQueryGeometry alloc] init];
  pigeonResult.value = value;
  pigeonResult.type = type;
  return pigeonResult;
}
+ (FLTRenderedQueryGeometry *)fromMap:(NSDictionary *)dict {
  FLTRenderedQueryGeometry *pigeonResult = [[FLTRenderedQueryGeometry alloc] init];
  pigeonResult.value = GetNullableObject(dict, @"value");
  NSAssert(pigeonResult.value != nil, @"");
  pigeonResult.type = [GetNullableObject(dict, @"type") integerValue];
  return pigeonResult;
}
+ (nullable FLTRenderedQueryGeometry *)nullableFromMap:(NSDictionary *)dict { return (dict) ? [FLTRenderedQueryGeometry fromMap:dict] : nil; }
- (NSDictionary *)toMap {
  return @{
    @"value" : (self.value ?: [NSNull null]),
    @"type" : @(self.type),
  };
}
@end

@implementation FLTOfflineRegionGeometryDefinition
+ (instancetype)makeWithStyleURL:(NSString *)styleURL
    geometry:(NSDictionary<NSString *, id> *)geometry
    minZoom:(NSNumber *)minZoom
    maxZoom:(NSNumber *)maxZoom
    pixelRatio:(NSNumber *)pixelRatio
    glyphsRasterizationMode:(FLTGlyphsRasterizationMode)glyphsRasterizationMode {
  FLTOfflineRegionGeometryDefinition* pigeonResult = [[FLTOfflineRegionGeometryDefinition alloc] init];
  pigeonResult.styleURL = styleURL;
  pigeonResult.geometry = geometry;
  pigeonResult.minZoom = minZoom;
  pigeonResult.maxZoom = maxZoom;
  pigeonResult.pixelRatio = pixelRatio;
  pigeonResult.glyphsRasterizationMode = glyphsRasterizationMode;
  return pigeonResult;
}
+ (FLTOfflineRegionGeometryDefinition *)fromMap:(NSDictionary *)dict {
  FLTOfflineRegionGeometryDefinition *pigeonResult = [[FLTOfflineRegionGeometryDefinition alloc] init];
  pigeonResult.styleURL = GetNullableObject(dict, @"styleURL");
  NSAssert(pigeonResult.styleURL != nil, @"");
  pigeonResult.geometry = GetNullableObject(dict, @"geometry");
  NSAssert(pigeonResult.geometry != nil, @"");
  pigeonResult.minZoom = GetNullableObject(dict, @"minZoom");
  NSAssert(pigeonResult.minZoom != nil, @"");
  pigeonResult.maxZoom = GetNullableObject(dict, @"maxZoom");
  NSAssert(pigeonResult.maxZoom != nil, @"");
  pigeonResult.pixelRatio = GetNullableObject(dict, @"pixelRatio");
  NSAssert(pigeonResult.pixelRatio != nil, @"");
  pigeonResult.glyphsRasterizationMode = [GetNullableObject(dict, @"glyphsRasterizationMode") integerValue];
  return pigeonResult;
}
+ (nullable FLTOfflineRegionGeometryDefinition *)nullableFromMap:(NSDictionary *)dict { return (dict) ? [FLTOfflineRegionGeometryDefinition fromMap:dict] : nil; }
- (NSDictionary *)toMap {
  return @{
    @"styleURL" : (self.styleURL ?: [NSNull null]),
    @"geometry" : (self.geometry ?: [NSNull null]),
    @"minZoom" : (self.minZoom ?: [NSNull null]),
    @"maxZoom" : (self.maxZoom ?: [NSNull null]),
    @"pixelRatio" : (self.pixelRatio ?: [NSNull null]),
    @"glyphsRasterizationMode" : @(self.glyphsRasterizationMode),
  };
}
@end

@implementation FLTOfflineRegionTilePyramidDefinition
+ (instancetype)makeWithStyleURL:(NSString *)styleURL
    bounds:(FLTCoordinateBounds *)bounds
    minZoom:(NSNumber *)minZoom
    maxZoom:(NSNumber *)maxZoom
    pixelRatio:(NSNumber *)pixelRatio
    glyphsRasterizationMode:(FLTGlyphsRasterizationMode)glyphsRasterizationMode {
  FLTOfflineRegionTilePyramidDefinition* pigeonResult = [[FLTOfflineRegionTilePyramidDefinition alloc] init];
  pigeonResult.styleURL = styleURL;
  pigeonResult.bounds = bounds;
  pigeonResult.minZoom = minZoom;
  pigeonResult.maxZoom = maxZoom;
  pigeonResult.pixelRatio = pixelRatio;
  pigeonResult.glyphsRasterizationMode = glyphsRasterizationMode;
  return pigeonResult;
}
+ (FLTOfflineRegionTilePyramidDefinition *)fromMap:(NSDictionary *)dict {
  FLTOfflineRegionTilePyramidDefinition *pigeonResult = [[FLTOfflineRegionTilePyramidDefinition alloc] init];
  pigeonResult.styleURL = GetNullableObject(dict, @"styleURL");
  NSAssert(pigeonResult.styleURL != nil, @"");
  pigeonResult.bounds = [FLTCoordinateBounds nullableFromMap:GetNullableObject(dict, @"bounds")];
  NSAssert(pigeonResult.bounds != nil, @"");
  pigeonResult.minZoom = GetNullableObject(dict, @"minZoom");
  NSAssert(pigeonResult.minZoom != nil, @"");
  pigeonResult.maxZoom = GetNullableObject(dict, @"maxZoom");
  NSAssert(pigeonResult.maxZoom != nil, @"");
  pigeonResult.pixelRatio = GetNullableObject(dict, @"pixelRatio");
  NSAssert(pigeonResult.pixelRatio != nil, @"");
  pigeonResult.glyphsRasterizationMode = [GetNullableObject(dict, @"glyphsRasterizationMode") integerValue];
  return pigeonResult;
}
+ (nullable FLTOfflineRegionTilePyramidDefinition *)nullableFromMap:(NSDictionary *)dict { return (dict) ? [FLTOfflineRegionTilePyramidDefinition fromMap:dict] : nil; }
- (NSDictionary *)toMap {
  return @{
    @"styleURL" : (self.styleURL ?: [NSNull null]),
    @"bounds" : (self.bounds ? [self.bounds toMap] : [NSNull null]),
    @"minZoom" : (self.minZoom ?: [NSNull null]),
    @"maxZoom" : (self.maxZoom ?: [NSNull null]),
    @"pixelRatio" : (self.pixelRatio ?: [NSNull null]),
    @"glyphsRasterizationMode" : @(self.glyphsRasterizationMode),
  };
}
@end

@implementation FLTProjectedMeters
+ (instancetype)makeWithNorthing:(NSNumber *)northing
    easting:(NSNumber *)easting {
  FLTProjectedMeters* pigeonResult = [[FLTProjectedMeters alloc] init];
  pigeonResult.northing = northing;
  pigeonResult.easting = easting;
  return pigeonResult;
}
+ (FLTProjectedMeters *)fromMap:(NSDictionary *)dict {
  FLTProjectedMeters *pigeonResult = [[FLTProjectedMeters alloc] init];
  pigeonResult.northing = GetNullableObject(dict, @"northing");
  NSAssert(pigeonResult.northing != nil, @"");
  pigeonResult.easting = GetNullableObject(dict, @"easting");
  NSAssert(pigeonResult.easting != nil, @"");
  return pigeonResult;
}
+ (nullable FLTProjectedMeters *)nullableFromMap:(NSDictionary *)dict { return (dict) ? [FLTProjectedMeters fromMap:dict] : nil; }
- (NSDictionary *)toMap {
  return @{
    @"northing" : (self.northing ?: [NSNull null]),
    @"easting" : (self.easting ?: [NSNull null]),
  };
}
@end

@implementation FLTMercatorCoordinate
+ (instancetype)makeWithX:(NSNumber *)x
    y:(NSNumber *)y {
  FLTMercatorCoordinate* pigeonResult = [[FLTMercatorCoordinate alloc] init];
  pigeonResult.x = x;
  pigeonResult.y = y;
  return pigeonResult;
}
+ (FLTMercatorCoordinate *)fromMap:(NSDictionary *)dict {
  FLTMercatorCoordinate *pigeonResult = [[FLTMercatorCoordinate alloc] init];
  pigeonResult.x = GetNullableObject(dict, @"x");
  NSAssert(pigeonResult.x != nil, @"");
  pigeonResult.y = GetNullableObject(dict, @"y");
  NSAssert(pigeonResult.y != nil, @"");
  return pigeonResult;
}
+ (nullable FLTMercatorCoordinate *)nullableFromMap:(NSDictionary *)dict { return (dict) ? [FLTMercatorCoordinate fromMap:dict] : nil; }
- (NSDictionary *)toMap {
  return @{
    @"x" : (self.x ?: [NSNull null]),
    @"y" : (self.y ?: [NSNull null]),
  };
}
@end

@implementation FLTResourceOptions
+ (instancetype)makeWithAccessToken:(NSString *)accessToken
    baseURL:(nullable NSString *)baseURL
    dataPath:(nullable NSString *)dataPath
    assetPath:(nullable NSString *)assetPath
    tileStoreUsageMode:(FLTTileStoreUsageMode)tileStoreUsageMode {
  FLTResourceOptions* pigeonResult = [[FLTResourceOptions alloc] init];
  pigeonResult.accessToken = accessToken;
  pigeonResult.baseURL = baseURL;
  pigeonResult.dataPath = dataPath;
  pigeonResult.assetPath = assetPath;
  pigeonResult.tileStoreUsageMode = tileStoreUsageMode;
  return pigeonResult;
}
+ (FLTResourceOptions *)fromMap:(NSDictionary *)dict {
  FLTResourceOptions *pigeonResult = [[FLTResourceOptions alloc] init];
  pigeonResult.accessToken = GetNullableObject(dict, @"accessToken");
  NSAssert(pigeonResult.accessToken != nil, @"");
  pigeonResult.baseURL = GetNullableObject(dict, @"baseURL");
  pigeonResult.dataPath = GetNullableObject(dict, @"dataPath");
  pigeonResult.assetPath = GetNullableObject(dict, @"assetPath");
  pigeonResult.tileStoreUsageMode = [GetNullableObject(dict, @"tileStoreUsageMode") integerValue];
  return pigeonResult;
}
+ (nullable FLTResourceOptions *)nullableFromMap:(NSDictionary *)dict { return (dict) ? [FLTResourceOptions fromMap:dict] : nil; }
- (NSDictionary *)toMap {
  return @{
    @"accessToken" : (self.accessToken ?: [NSNull null]),
    @"baseURL" : (self.baseURL ?: [NSNull null]),
    @"dataPath" : (self.dataPath ?: [NSNull null]),
    @"assetPath" : (self.assetPath ?: [NSNull null]),
    @"tileStoreUsageMode" : @(self.tileStoreUsageMode),
  };
}
@end

@implementation FLTStyleObjectInfo
+ (instancetype)makeWithId:(NSString *)id
    type:(NSString *)type {
  FLTStyleObjectInfo* pigeonResult = [[FLTStyleObjectInfo alloc] init];
  pigeonResult.id = id;
  pigeonResult.type = type;
  return pigeonResult;
}
+ (FLTStyleObjectInfo *)fromMap:(NSDictionary *)dict {
  FLTStyleObjectInfo *pigeonResult = [[FLTStyleObjectInfo alloc] init];
  pigeonResult.id = GetNullableObject(dict, @"id");
  NSAssert(pigeonResult.id != nil, @"");
  pigeonResult.type = GetNullableObject(dict, @"type");
  NSAssert(pigeonResult.type != nil, @"");
  return pigeonResult;
}
+ (nullable FLTStyleObjectInfo *)nullableFromMap:(NSDictionary *)dict { return (dict) ? [FLTStyleObjectInfo fromMap:dict] : nil; }
- (NSDictionary *)toMap {
  return @{
    @"id" : (self.id ?: [NSNull null]),
    @"type" : (self.type ?: [NSNull null]),
  };
}
@end

@implementation FLTMbxImage
+ (instancetype)makeWithWidth:(NSNumber *)width
    height:(NSNumber *)height
    data:(FlutterStandardTypedData *)data {
  FLTMbxImage* pigeonResult = [[FLTMbxImage alloc] init];
  pigeonResult.width = width;
  pigeonResult.height = height;
  pigeonResult.data = data;
  return pigeonResult;
}
+ (FLTMbxImage *)fromMap:(NSDictionary *)dict {
  FLTMbxImage *pigeonResult = [[FLTMbxImage alloc] init];
  pigeonResult.width = GetNullableObject(dict, @"width");
  NSAssert(pigeonResult.width != nil, @"");
  pigeonResult.height = GetNullableObject(dict, @"height");
  NSAssert(pigeonResult.height != nil, @"");
  pigeonResult.data = GetNullableObject(dict, @"data");
  NSAssert(pigeonResult.data != nil, @"");
  return pigeonResult;
}
+ (nullable FLTMbxImage *)nullableFromMap:(NSDictionary *)dict { return (dict) ? [FLTMbxImage fromMap:dict] : nil; }
- (NSDictionary *)toMap {
  return @{
    @"width" : (self.width ?: [NSNull null]),
    @"height" : (self.height ?: [NSNull null]),
    @"data" : (self.data ?: [NSNull null]),
  };
}
@end

@implementation FLTImageStretches
+ (instancetype)makeWithFirst:(NSNumber *)first
    second:(NSNumber *)second {
  FLTImageStretches* pigeonResult = [[FLTImageStretches alloc] init];
  pigeonResult.first = first;
  pigeonResult.second = second;
  return pigeonResult;
}
+ (FLTImageStretches *)fromMap:(NSDictionary *)dict {
  FLTImageStretches *pigeonResult = [[FLTImageStretches alloc] init];
  pigeonResult.first = GetNullableObject(dict, @"first");
  NSAssert(pigeonResult.first != nil, @"");
  pigeonResult.second = GetNullableObject(dict, @"second");
  NSAssert(pigeonResult.second != nil, @"");
  return pigeonResult;
}
+ (nullable FLTImageStretches *)nullableFromMap:(NSDictionary *)dict { return (dict) ? [FLTImageStretches fromMap:dict] : nil; }
- (NSDictionary *)toMap {
  return @{
    @"first" : (self.first ?: [NSNull null]),
    @"second" : (self.second ?: [NSNull null]),
  };
}
@end

@implementation FLTImageContent
+ (instancetype)makeWithLeft:(NSNumber *)left
    top:(NSNumber *)top
    right:(NSNumber *)right
    bottom:(NSNumber *)bottom {
  FLTImageContent* pigeonResult = [[FLTImageContent alloc] init];
  pigeonResult.left = left;
  pigeonResult.top = top;
  pigeonResult.right = right;
  pigeonResult.bottom = bottom;
  return pigeonResult;
}
+ (FLTImageContent *)fromMap:(NSDictionary *)dict {
  FLTImageContent *pigeonResult = [[FLTImageContent alloc] init];
  pigeonResult.left = GetNullableObject(dict, @"left");
  NSAssert(pigeonResult.left != nil, @"");
  pigeonResult.top = GetNullableObject(dict, @"top");
  NSAssert(pigeonResult.top != nil, @"");
  pigeonResult.right = GetNullableObject(dict, @"right");
  NSAssert(pigeonResult.right != nil, @"");
  pigeonResult.bottom = GetNullableObject(dict, @"bottom");
  NSAssert(pigeonResult.bottom != nil, @"");
  return pigeonResult;
}
+ (nullable FLTImageContent *)nullableFromMap:(NSDictionary *)dict { return (dict) ? [FLTImageContent fromMap:dict] : nil; }
- (NSDictionary *)toMap {
  return @{
    @"left" : (self.left ?: [NSNull null]),
    @"top" : (self.top ?: [NSNull null]),
    @"right" : (self.right ?: [NSNull null]),
    @"bottom" : (self.bottom ?: [NSNull null]),
  };
}
@end

@implementation FLTTransitionOptions
+ (instancetype)makeWithDuration:(nullable NSNumber *)duration
    delay:(nullable NSNumber *)delay
    enablePlacementTransitions:(nullable NSNumber *)enablePlacementTransitions {
  FLTTransitionOptions* pigeonResult = [[FLTTransitionOptions alloc] init];
  pigeonResult.duration = duration;
  pigeonResult.delay = delay;
  pigeonResult.enablePlacementTransitions = enablePlacementTransitions;
  return pigeonResult;
}
+ (FLTTransitionOptions *)fromMap:(NSDictionary *)dict {
  FLTTransitionOptions *pigeonResult = [[FLTTransitionOptions alloc] init];
  pigeonResult.duration = GetNullableObject(dict, @"duration");
  pigeonResult.delay = GetNullableObject(dict, @"delay");
  pigeonResult.enablePlacementTransitions = GetNullableObject(dict, @"enablePlacementTransitions");
  return pigeonResult;
}
+ (nullable FLTTransitionOptions *)nullableFromMap:(NSDictionary *)dict { return (dict) ? [FLTTransitionOptions fromMap:dict] : nil; }
- (NSDictionary *)toMap {
  return @{
    @"duration" : (self.duration ?: [NSNull null]),
    @"delay" : (self.delay ?: [NSNull null]),
    @"enablePlacementTransitions" : (self.enablePlacementTransitions ?: [NSNull null]),
  };
}
@end

@implementation FLTCanonicalTileID
+ (instancetype)makeWithZ:(NSNumber *)z
    x:(NSNumber *)x
    y:(NSNumber *)y {
  FLTCanonicalTileID* pigeonResult = [[FLTCanonicalTileID alloc] init];
  pigeonResult.z = z;
  pigeonResult.x = x;
  pigeonResult.y = y;
  return pigeonResult;
}
+ (FLTCanonicalTileID *)fromMap:(NSDictionary *)dict {
  FLTCanonicalTileID *pigeonResult = [[FLTCanonicalTileID alloc] init];
  pigeonResult.z = GetNullableObject(dict, @"z");
  NSAssert(pigeonResult.z != nil, @"");
  pigeonResult.x = GetNullableObject(dict, @"x");
  NSAssert(pigeonResult.x != nil, @"");
  pigeonResult.y = GetNullableObject(dict, @"y");
  NSAssert(pigeonResult.y != nil, @"");
  return pigeonResult;
}
+ (nullable FLTCanonicalTileID *)nullableFromMap:(NSDictionary *)dict { return (dict) ? [FLTCanonicalTileID fromMap:dict] : nil; }
- (NSDictionary *)toMap {
  return @{
    @"z" : (self.z ?: [NSNull null]),
    @"x" : (self.x ?: [NSNull null]),
    @"y" : (self.y ?: [NSNull null]),
  };
}
@end

@implementation FLTStylePropertyValue
+ (instancetype)makeWithValue:(NSString *)value
    kind:(FLTStylePropertyValueKind)kind {
  FLTStylePropertyValue* pigeonResult = [[FLTStylePropertyValue alloc] init];
  pigeonResult.value = value;
  pigeonResult.kind = kind;
  return pigeonResult;
}
+ (FLTStylePropertyValue *)fromMap:(NSDictionary *)dict {
  FLTStylePropertyValue *pigeonResult = [[FLTStylePropertyValue alloc] init];
  pigeonResult.value = GetNullableObject(dict, @"value");
  NSAssert(pigeonResult.value != nil, @"");
  pigeonResult.kind = [GetNullableObject(dict, @"kind") integerValue];
  return pigeonResult;
}
+ (nullable FLTStylePropertyValue *)nullableFromMap:(NSDictionary *)dict { return (dict) ? [FLTStylePropertyValue fromMap:dict] : nil; }
- (NSDictionary *)toMap {
  return @{
    @"value" : (self.value ?: [NSNull null]),
    @"kind" : @(self.kind),
  };
}
@end

@interface FLT_AnimationManagerCodecReader : FlutterStandardReader
@end
@implementation FLT_AnimationManagerCodecReader
- (nullable id)readValueOfType:(UInt8)type 
{
  switch (type) {
    case 128:     
      return [FLTCameraOptions fromMap:[self readValue]];
    
    case 129:     
      return [FLTMapAnimationOptions fromMap:[self readValue]];
    
    case 130:     
      return [FLTMbxEdgeInsets fromMap:[self readValue]];
    
    case 131:     
      return [FLTScreenCoordinate fromMap:[self readValue]];
    
    case 132:     
      return [FLTScreenCoordinate fromMap:[self readValue]];
    
    default:    
      return [super readValueOfType:type];
    
  }
}
@end

@interface FLT_AnimationManagerCodecWriter : FlutterStandardWriter
@end
@implementation FLT_AnimationManagerCodecWriter
- (void)writeValue:(id)value 
{
  if ([value isKindOfClass:[FLTCameraOptions class]]) {
    [self writeByte:128];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTMapAnimationOptions class]]) {
    [self writeByte:129];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTMbxEdgeInsets class]]) {
    [self writeByte:130];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTScreenCoordinate class]]) {
    [self writeByte:131];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTScreenCoordinate class]]) {
    [self writeByte:132];
    [self writeValue:[value toMap]];
  } else 
{
    [super writeValue:value];
  }
}
@end

@interface FLT_AnimationManagerCodecReaderWriter : FlutterStandardReaderWriter
@end
@implementation FLT_AnimationManagerCodecReaderWriter
- (FlutterStandardWriter *)writerWithData:(NSMutableData *)data {
  return [[FLT_AnimationManagerCodecWriter alloc] initWithData:data];
}
- (FlutterStandardReader *)readerWithData:(NSData *)data {
  return [[FLT_AnimationManagerCodecReader alloc] initWithData:data];
}
@end

NSObject<FlutterMessageCodec> *FLT_AnimationManagerGetCodec() {
  static dispatch_once_t sPred = 0;
  static FlutterStandardMessageCodec *sSharedObject = nil;
  dispatch_once(&sPred, ^{
    FLT_AnimationManagerCodecReaderWriter *readerWriter = [[FLT_AnimationManagerCodecReaderWriter alloc] init];
    sSharedObject = [FlutterStandardMessageCodec codecWithReaderWriter:readerWriter];
  });
  return sSharedObject;
}


void FLT_AnimationManagerSetup(id<FlutterBinaryMessenger> binaryMessenger, NSObject<FLT_AnimationManager> *api) {
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon._AnimationManager.easeTo"
        binaryMessenger:binaryMessenger
        codec:FLT_AnimationManagerGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(easeToCameraOptions:mapAnimationOptions:error:)], @"FLT_AnimationManager api (%@) doesn't respond to @selector(easeToCameraOptions:mapAnimationOptions:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        FLTCameraOptions *arg_cameraOptions = GetNullableObjectAtIndex(args, 0);
        FLTMapAnimationOptions *arg_mapAnimationOptions = GetNullableObjectAtIndex(args, 1);
        FlutterError *error;
        [api easeToCameraOptions:arg_cameraOptions mapAnimationOptions:arg_mapAnimationOptions error:&error];
        callback(wrapResult(nil, error));
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon._AnimationManager.flyTo"
        binaryMessenger:binaryMessenger
        codec:FLT_AnimationManagerGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(flyToCameraOptions:mapAnimationOptions:error:)], @"FLT_AnimationManager api (%@) doesn't respond to @selector(flyToCameraOptions:mapAnimationOptions:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        FLTCameraOptions *arg_cameraOptions = GetNullableObjectAtIndex(args, 0);
        FLTMapAnimationOptions *arg_mapAnimationOptions = GetNullableObjectAtIndex(args, 1);
        FlutterError *error;
        [api flyToCameraOptions:arg_cameraOptions mapAnimationOptions:arg_mapAnimationOptions error:&error];
        callback(wrapResult(nil, error));
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon._AnimationManager.pitchBy"
        binaryMessenger:binaryMessenger
        codec:FLT_AnimationManagerGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(pitchByPitch:mapAnimationOptions:error:)], @"FLT_AnimationManager api (%@) doesn't respond to @selector(pitchByPitch:mapAnimationOptions:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSNumber *arg_pitch = GetNullableObjectAtIndex(args, 0);
        FLTMapAnimationOptions *arg_mapAnimationOptions = GetNullableObjectAtIndex(args, 1);
        FlutterError *error;
        [api pitchByPitch:arg_pitch mapAnimationOptions:arg_mapAnimationOptions error:&error];
        callback(wrapResult(nil, error));
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon._AnimationManager.scaleBy"
        binaryMessenger:binaryMessenger
        codec:FLT_AnimationManagerGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(scaleByAmount:screenCoordinate:mapAnimationOptions:error:)], @"FLT_AnimationManager api (%@) doesn't respond to @selector(scaleByAmount:screenCoordinate:mapAnimationOptions:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSNumber *arg_amount = GetNullableObjectAtIndex(args, 0);
        FLTScreenCoordinate *arg_screenCoordinate = GetNullableObjectAtIndex(args, 1);
        FLTMapAnimationOptions *arg_mapAnimationOptions = GetNullableObjectAtIndex(args, 2);
        FlutterError *error;
        [api scaleByAmount:arg_amount screenCoordinate:arg_screenCoordinate mapAnimationOptions:arg_mapAnimationOptions error:&error];
        callback(wrapResult(nil, error));
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon._AnimationManager.moveBy"
        binaryMessenger:binaryMessenger
        codec:FLT_AnimationManagerGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(moveByScreenCoordinate:mapAnimationOptions:error:)], @"FLT_AnimationManager api (%@) doesn't respond to @selector(moveByScreenCoordinate:mapAnimationOptions:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        FLTScreenCoordinate *arg_screenCoordinate = GetNullableObjectAtIndex(args, 0);
        FLTMapAnimationOptions *arg_mapAnimationOptions = GetNullableObjectAtIndex(args, 1);
        FlutterError *error;
        [api moveByScreenCoordinate:arg_screenCoordinate mapAnimationOptions:arg_mapAnimationOptions error:&error];
        callback(wrapResult(nil, error));
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon._AnimationManager.rotateBy"
        binaryMessenger:binaryMessenger
        codec:FLT_AnimationManagerGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(rotateByFirst:second:mapAnimationOptions:error:)], @"FLT_AnimationManager api (%@) doesn't respond to @selector(rotateByFirst:second:mapAnimationOptions:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        FLTScreenCoordinate *arg_first = GetNullableObjectAtIndex(args, 0);
        FLTScreenCoordinate *arg_second = GetNullableObjectAtIndex(args, 1);
        FLTMapAnimationOptions *arg_mapAnimationOptions = GetNullableObjectAtIndex(args, 2);
        FlutterError *error;
        [api rotateByFirst:arg_first second:arg_second mapAnimationOptions:arg_mapAnimationOptions error:&error];
        callback(wrapResult(nil, error));
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon._AnimationManager.cancelCameraAnimation"
        binaryMessenger:binaryMessenger
        codec:FLT_AnimationManagerGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(cancelCameraAnimationWithError:)], @"FLT_AnimationManager api (%@) doesn't respond to @selector(cancelCameraAnimationWithError:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        [api cancelCameraAnimationWithError:&error];
        callback(wrapResult(nil, error));
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
}
@interface FLT_CameraManagerCodecReader : FlutterStandardReader
@end
@implementation FLT_CameraManagerCodecReader
- (nullable id)readValueOfType:(UInt8)type 
{
  switch (type) {
    case 128:     
      return [FLTCameraBounds fromMap:[self readValue]];
    
    case 129:     
      return [FLTCameraBoundsOptions fromMap:[self readValue]];
    
    case 130:     
      return [FLTCameraOptions fromMap:[self readValue]];
    
    case 131:     
      return [FLTCameraState fromMap:[self readValue]];
    
    case 132:     
      return [FLTCanonicalTileID fromMap:[self readValue]];
    
    case 133:     
      return [FLTCoordinateBounds fromMap:[self readValue]];
    
    case 134:     
      return [FLTCoordinateBoundsZoom fromMap:[self readValue]];
    
    case 135:     
      return [FLTFeatureExtensionValue fromMap:[self readValue]];
    
    case 136:     
      return [FLTGlyphsRasterizationOptions fromMap:[self readValue]];
    
    case 137:     
      return [FLTImageContent fromMap:[self readValue]];
    
    case 138:     
      return [FLTImageStretches fromMap:[self readValue]];
    
    case 139:     
      return [FLTLayerPosition fromMap:[self readValue]];
    
    case 140:     
      return [FLTMapAnimationOptions fromMap:[self readValue]];
    
    case 141:     
      return [FLTMapDebugOptions fromMap:[self readValue]];
    
    case 142:     
      return [FLTMapMemoryBudgetInMegabytes fromMap:[self readValue]];
    
    case 143:     
      return [FLTMapMemoryBudgetInTiles fromMap:[self readValue]];
    
    case 144:     
      return [FLTMapOptions fromMap:[self readValue]];
    
    case 145:     
      return [FLTMbxEdgeInsets fromMap:[self readValue]];
    
    case 146:     
      return [FLTMbxImage fromMap:[self readValue]];
    
    case 147:     
      return [FLTMercatorCoordinate fromMap:[self readValue]];
    
    case 148:     
      return [FLTOfflineRegionGeometryDefinition fromMap:[self readValue]];
    
    case 149:     
      return [FLTOfflineRegionTilePyramidDefinition fromMap:[self readValue]];
    
    case 150:     
      return [FLTProjectedMeters fromMap:[self readValue]];
    
    case 151:     
      return [FLTQueriedFeature fromMap:[self readValue]];
    
    case 152:     
      return [FLTRenderedQueryGeometry fromMap:[self readValue]];
    
    case 153:     
      return [FLTRenderedQueryOptions fromMap:[self readValue]];
    
    case 154:     
      return [FLTResourceOptions fromMap:[self readValue]];
    
    case 155:     
      return [FLTScreenBox fromMap:[self readValue]];
    
    case 156:     
      return [FLTScreenCoordinate fromMap:[self readValue]];
    
    case 157:     
      return [FLTSize fromMap:[self readValue]];
    
    case 158:     
      return [FLTSourceQueryOptions fromMap:[self readValue]];
    
    case 159:     
      return [FLTStyleObjectInfo fromMap:[self readValue]];
    
    case 160:     
      return [FLTStylePropertyValue fromMap:[self readValue]];
    
    case 161:     
      return [FLTTransitionOptions fromMap:[self readValue]];
    
    default:    
      return [super readValueOfType:type];
    
  }
}
@end

@interface FLT_CameraManagerCodecWriter : FlutterStandardWriter
@end
@implementation FLT_CameraManagerCodecWriter
- (void)writeValue:(id)value 
{
  if ([value isKindOfClass:[FLTCameraBounds class]]) {
    [self writeByte:128];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTCameraBoundsOptions class]]) {
    [self writeByte:129];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTCameraOptions class]]) {
    [self writeByte:130];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTCameraState class]]) {
    [self writeByte:131];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTCanonicalTileID class]]) {
    [self writeByte:132];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTCoordinateBounds class]]) {
    [self writeByte:133];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTCoordinateBoundsZoom class]]) {
    [self writeByte:134];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTFeatureExtensionValue class]]) {
    [self writeByte:135];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTGlyphsRasterizationOptions class]]) {
    [self writeByte:136];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTImageContent class]]) {
    [self writeByte:137];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTImageStretches class]]) {
    [self writeByte:138];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTLayerPosition class]]) {
    [self writeByte:139];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTMapAnimationOptions class]]) {
    [self writeByte:140];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTMapDebugOptions class]]) {
    [self writeByte:141];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTMapMemoryBudgetInMegabytes class]]) {
    [self writeByte:142];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTMapMemoryBudgetInTiles class]]) {
    [self writeByte:143];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTMapOptions class]]) {
    [self writeByte:144];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTMbxEdgeInsets class]]) {
    [self writeByte:145];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTMbxImage class]]) {
    [self writeByte:146];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTMercatorCoordinate class]]) {
    [self writeByte:147];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTOfflineRegionGeometryDefinition class]]) {
    [self writeByte:148];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTOfflineRegionTilePyramidDefinition class]]) {
    [self writeByte:149];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTProjectedMeters class]]) {
    [self writeByte:150];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTQueriedFeature class]]) {
    [self writeByte:151];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTRenderedQueryGeometry class]]) {
    [self writeByte:152];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTRenderedQueryOptions class]]) {
    [self writeByte:153];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTResourceOptions class]]) {
    [self writeByte:154];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTScreenBox class]]) {
    [self writeByte:155];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTScreenCoordinate class]]) {
    [self writeByte:156];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTSize class]]) {
    [self writeByte:157];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTSourceQueryOptions class]]) {
    [self writeByte:158];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTStyleObjectInfo class]]) {
    [self writeByte:159];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTStylePropertyValue class]]) {
    [self writeByte:160];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTTransitionOptions class]]) {
    [self writeByte:161];
    [self writeValue:[value toMap]];
  } else 
{
    [super writeValue:value];
  }
}
@end

@interface FLT_CameraManagerCodecReaderWriter : FlutterStandardReaderWriter
@end
@implementation FLT_CameraManagerCodecReaderWriter
- (FlutterStandardWriter *)writerWithData:(NSMutableData *)data {
  return [[FLT_CameraManagerCodecWriter alloc] initWithData:data];
}
- (FlutterStandardReader *)readerWithData:(NSData *)data {
  return [[FLT_CameraManagerCodecReader alloc] initWithData:data];
}
@end

NSObject<FlutterMessageCodec> *FLT_CameraManagerGetCodec() {
  static dispatch_once_t sPred = 0;
  static FlutterStandardMessageCodec *sSharedObject = nil;
  dispatch_once(&sPred, ^{
    FLT_CameraManagerCodecReaderWriter *readerWriter = [[FLT_CameraManagerCodecReaderWriter alloc] init];
    sSharedObject = [FlutterStandardMessageCodec codecWithReaderWriter:readerWriter];
  });
  return sSharedObject;
}


void FLT_CameraManagerSetup(id<FlutterBinaryMessenger> binaryMessenger, NSObject<FLT_CameraManager> *api) {
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon._CameraManager.cameraForCoordinateBounds"
        binaryMessenger:binaryMessenger
        codec:FLT_CameraManagerGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(cameraForCoordinateBoundsBounds:padding:bearing:pitch:error:)], @"FLT_CameraManager api (%@) doesn't respond to @selector(cameraForCoordinateBoundsBounds:padding:bearing:pitch:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        FLTCoordinateBounds *arg_bounds = GetNullableObjectAtIndex(args, 0);
        FLTMbxEdgeInsets *arg_padding = GetNullableObjectAtIndex(args, 1);
        NSNumber *arg_bearing = GetNullableObjectAtIndex(args, 2);
        NSNumber *arg_pitch = GetNullableObjectAtIndex(args, 3);
        FlutterError *error;
        FLTCameraOptions *output = [api cameraForCoordinateBoundsBounds:arg_bounds padding:arg_padding bearing:arg_bearing pitch:arg_pitch error:&error];
        callback(wrapResult(output, error));
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon._CameraManager.cameraForCoordinates"
        binaryMessenger:binaryMessenger
        codec:FLT_CameraManagerGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(cameraForCoordinatesCoordinates:padding:bearing:pitch:error:)], @"FLT_CameraManager api (%@) doesn't respond to @selector(cameraForCoordinatesCoordinates:padding:bearing:pitch:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSArray<NSDictionary<NSString *, id> *> *arg_coordinates = GetNullableObjectAtIndex(args, 0);
        FLTMbxEdgeInsets *arg_padding = GetNullableObjectAtIndex(args, 1);
        NSNumber *arg_bearing = GetNullableObjectAtIndex(args, 2);
        NSNumber *arg_pitch = GetNullableObjectAtIndex(args, 3);
        FlutterError *error;
        FLTCameraOptions *output = [api cameraForCoordinatesCoordinates:arg_coordinates padding:arg_padding bearing:arg_bearing pitch:arg_pitch error:&error];
        callback(wrapResult(output, error));
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon._CameraManager.cameraForCoordinatesCameraOptions"
        binaryMessenger:binaryMessenger
        codec:FLT_CameraManagerGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(cameraForCoordinatesCameraOptionsCoordinates:camera:box:error:)], @"FLT_CameraManager api (%@) doesn't respond to @selector(cameraForCoordinatesCameraOptionsCoordinates:camera:box:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSArray<NSDictionary<NSString *, id> *> *arg_coordinates = GetNullableObjectAtIndex(args, 0);
        FLTCameraOptions *arg_camera = GetNullableObjectAtIndex(args, 1);
        FLTScreenBox *arg_box = GetNullableObjectAtIndex(args, 2);
        FlutterError *error;
        FLTCameraOptions *output = [api cameraForCoordinatesCameraOptionsCoordinates:arg_coordinates camera:arg_camera box:arg_box error:&error];
        callback(wrapResult(output, error));
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon._CameraManager.cameraForGeometry"
        binaryMessenger:binaryMessenger
        codec:FLT_CameraManagerGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(cameraForGeometryGeometry:padding:bearing:pitch:error:)], @"FLT_CameraManager api (%@) doesn't respond to @selector(cameraForGeometryGeometry:padding:bearing:pitch:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSDictionary<NSString *, id> *arg_geometry = GetNullableObjectAtIndex(args, 0);
        FLTMbxEdgeInsets *arg_padding = GetNullableObjectAtIndex(args, 1);
        NSNumber *arg_bearing = GetNullableObjectAtIndex(args, 2);
        NSNumber *arg_pitch = GetNullableObjectAtIndex(args, 3);
        FlutterError *error;
        FLTCameraOptions *output = [api cameraForGeometryGeometry:arg_geometry padding:arg_padding bearing:arg_bearing pitch:arg_pitch error:&error];
        callback(wrapResult(output, error));
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon._CameraManager.coordinateBoundsForCamera"
        binaryMessenger:binaryMessenger
        codec:FLT_CameraManagerGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(coordinateBoundsForCameraCamera:error:)], @"FLT_CameraManager api (%@) doesn't respond to @selector(coordinateBoundsForCameraCamera:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        FLTCameraOptions *arg_camera = GetNullableObjectAtIndex(args, 0);
        FlutterError *error;
        FLTCoordinateBounds *output = [api coordinateBoundsForCameraCamera:arg_camera error:&error];
        callback(wrapResult(output, error));
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon._CameraManager.coordinateBoundsForCameraUnwrapped"
        binaryMessenger:binaryMessenger
        codec:FLT_CameraManagerGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(coordinateBoundsForCameraUnwrappedCamera:error:)], @"FLT_CameraManager api (%@) doesn't respond to @selector(coordinateBoundsForCameraUnwrappedCamera:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        FLTCameraOptions *arg_camera = GetNullableObjectAtIndex(args, 0);
        FlutterError *error;
        FLTCoordinateBounds *output = [api coordinateBoundsForCameraUnwrappedCamera:arg_camera error:&error];
        callback(wrapResult(output, error));
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon._CameraManager.coordinateBoundsZoomForCamera"
        binaryMessenger:binaryMessenger
        codec:FLT_CameraManagerGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(coordinateBoundsZoomForCameraCamera:error:)], @"FLT_CameraManager api (%@) doesn't respond to @selector(coordinateBoundsZoomForCameraCamera:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        FLTCameraOptions *arg_camera = GetNullableObjectAtIndex(args, 0);
        FlutterError *error;
        FLTCoordinateBoundsZoom *output = [api coordinateBoundsZoomForCameraCamera:arg_camera error:&error];
        callback(wrapResult(output, error));
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon._CameraManager.coordinateBoundsZoomForCameraUnwrapped"
        binaryMessenger:binaryMessenger
        codec:FLT_CameraManagerGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(coordinateBoundsZoomForCameraUnwrappedCamera:error:)], @"FLT_CameraManager api (%@) doesn't respond to @selector(coordinateBoundsZoomForCameraUnwrappedCamera:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        FLTCameraOptions *arg_camera = GetNullableObjectAtIndex(args, 0);
        FlutterError *error;
        FLTCoordinateBoundsZoom *output = [api coordinateBoundsZoomForCameraUnwrappedCamera:arg_camera error:&error];
        callback(wrapResult(output, error));
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon._CameraManager.pixelForCoordinate"
        binaryMessenger:binaryMessenger
        codec:FLT_CameraManagerGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(pixelForCoordinateCoordinate:error:)], @"FLT_CameraManager api (%@) doesn't respond to @selector(pixelForCoordinateCoordinate:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSDictionary<NSString *, id> *arg_coordinate = GetNullableObjectAtIndex(args, 0);
        FlutterError *error;
        FLTScreenCoordinate *output = [api pixelForCoordinateCoordinate:arg_coordinate error:&error];
        callback(wrapResult(output, error));
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon._CameraManager.coordinateForPixel"
        binaryMessenger:binaryMessenger
        codec:FLT_CameraManagerGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(coordinateForPixelPixel:error:)], @"FLT_CameraManager api (%@) doesn't respond to @selector(coordinateForPixelPixel:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        FLTScreenCoordinate *arg_pixel = GetNullableObjectAtIndex(args, 0);
        FlutterError *error;
        NSDictionary<NSString *, id> *output = [api coordinateForPixelPixel:arg_pixel error:&error];
        callback(wrapResult(output, error));
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon._CameraManager.pixelsForCoordinates"
        binaryMessenger:binaryMessenger
        codec:FLT_CameraManagerGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(pixelsForCoordinatesCoordinates:error:)], @"FLT_CameraManager api (%@) doesn't respond to @selector(pixelsForCoordinatesCoordinates:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSArray<NSDictionary<NSString *, id> *> *arg_coordinates = GetNullableObjectAtIndex(args, 0);
        FlutterError *error;
        NSArray<FLTScreenCoordinate *> *output = [api pixelsForCoordinatesCoordinates:arg_coordinates error:&error];
        callback(wrapResult(output, error));
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon._CameraManager.coordinatesForPixels"
        binaryMessenger:binaryMessenger
        codec:FLT_CameraManagerGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(coordinatesForPixelsPixels:error:)], @"FLT_CameraManager api (%@) doesn't respond to @selector(coordinatesForPixelsPixels:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSArray<FLTScreenCoordinate *> *arg_pixels = GetNullableObjectAtIndex(args, 0);
        FlutterError *error;
        NSArray<NSDictionary<NSString *, id> *> *output = [api coordinatesForPixelsPixels:arg_pixels error:&error];
        callback(wrapResult(output, error));
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon._CameraManager.setCamera"
        binaryMessenger:binaryMessenger
        codec:FLT_CameraManagerGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(setCameraCameraOptions:error:)], @"FLT_CameraManager api (%@) doesn't respond to @selector(setCameraCameraOptions:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        FLTCameraOptions *arg_cameraOptions = GetNullableObjectAtIndex(args, 0);
        FlutterError *error;
        [api setCameraCameraOptions:arg_cameraOptions error:&error];
        callback(wrapResult(nil, error));
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon._CameraManager.getCameraState"
        binaryMessenger:binaryMessenger
        codec:FLT_CameraManagerGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(getCameraStateWithError:)], @"FLT_CameraManager api (%@) doesn't respond to @selector(getCameraStateWithError:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        FLTCameraState *output = [api getCameraStateWithError:&error];
        callback(wrapResult(output, error));
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon._CameraManager.setBounds"
        binaryMessenger:binaryMessenger
        codec:FLT_CameraManagerGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(setBoundsOptions:error:)], @"FLT_CameraManager api (%@) doesn't respond to @selector(setBoundsOptions:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        FLTCameraBoundsOptions *arg_options = GetNullableObjectAtIndex(args, 0);
        FlutterError *error;
        [api setBoundsOptions:arg_options error:&error];
        callback(wrapResult(nil, error));
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon._CameraManager.getBounds"
        binaryMessenger:binaryMessenger
        codec:FLT_CameraManagerGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(getBoundsWithError:)], @"FLT_CameraManager api (%@) doesn't respond to @selector(getBoundsWithError:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        FLTCameraBounds *output = [api getBoundsWithError:&error];
        callback(wrapResult(output, error));
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon._CameraManager.dragStart"
        binaryMessenger:binaryMessenger
        codec:FLT_CameraManagerGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(dragStartPoint:error:)], @"FLT_CameraManager api (%@) doesn't respond to @selector(dragStartPoint:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        FLTScreenCoordinate *arg_point = GetNullableObjectAtIndex(args, 0);
        FlutterError *error;
        [api dragStartPoint:arg_point error:&error];
        callback(wrapResult(nil, error));
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon._CameraManager.getDragCameraOptions"
        binaryMessenger:binaryMessenger
        codec:FLT_CameraManagerGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(getDragCameraOptionsFromPoint:toPoint:error:)], @"FLT_CameraManager api (%@) doesn't respond to @selector(getDragCameraOptionsFromPoint:toPoint:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        FLTScreenCoordinate *arg_fromPoint = GetNullableObjectAtIndex(args, 0);
        FLTScreenCoordinate *arg_toPoint = GetNullableObjectAtIndex(args, 1);
        FlutterError *error;
        FLTCameraOptions *output = [api getDragCameraOptionsFromPoint:arg_fromPoint toPoint:arg_toPoint error:&error];
        callback(wrapResult(output, error));
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon._CameraManager.dragEnd"
        binaryMessenger:binaryMessenger
        codec:FLT_CameraManagerGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(dragEndWithError:)], @"FLT_CameraManager api (%@) doesn't respond to @selector(dragEndWithError:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        [api dragEndWithError:&error];
        callback(wrapResult(nil, error));
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
}
@interface FLT_MapInterfaceCodecReader : FlutterStandardReader
@end
@implementation FLT_MapInterfaceCodecReader
- (nullable id)readValueOfType:(UInt8)type 
{
  switch (type) {
    case 128:     
      return [FLTCameraBounds fromMap:[self readValue]];
    
    case 129:     
      return [FLTCameraBoundsOptions fromMap:[self readValue]];
    
    case 130:     
      return [FLTCameraOptions fromMap:[self readValue]];
    
    case 131:     
      return [FLTCameraState fromMap:[self readValue]];
    
    case 132:     
      return [FLTCanonicalTileID fromMap:[self readValue]];
    
    case 133:     
      return [FLTCoordinateBounds fromMap:[self readValue]];
    
    case 134:     
      return [FLTCoordinateBoundsZoom fromMap:[self readValue]];
    
    case 135:     
      return [FLTFeatureExtensionValue fromMap:[self readValue]];
    
    case 136:     
      return [FLTGlyphsRasterizationOptions fromMap:[self readValue]];
    
    case 137:     
      return [FLTImageContent fromMap:[self readValue]];
    
    case 138:     
      return [FLTImageStretches fromMap:[self readValue]];
    
    case 139:     
      return [FLTLayerPosition fromMap:[self readValue]];
    
    case 140:     
      return [FLTMapAnimationOptions fromMap:[self readValue]];
    
    case 141:     
      return [FLTMapDebugOptions fromMap:[self readValue]];
    
    case 142:     
      return [FLTMapMemoryBudgetInMegabytes fromMap:[self readValue]];
    
    case 143:     
      return [FLTMapMemoryBudgetInTiles fromMap:[self readValue]];
    
    case 144:     
      return [FLTMapOptions fromMap:[self readValue]];
    
    case 145:     
      return [FLTMbxEdgeInsets fromMap:[self readValue]];
    
    case 146:     
      return [FLTMbxImage fromMap:[self readValue]];
    
    case 147:     
      return [FLTMercatorCoordinate fromMap:[self readValue]];
    
    case 148:     
      return [FLTOfflineRegionGeometryDefinition fromMap:[self readValue]];
    
    case 149:     
      return [FLTOfflineRegionTilePyramidDefinition fromMap:[self readValue]];
    
    case 150:     
      return [FLTProjectedMeters fromMap:[self readValue]];
    
    case 151:     
      return [FLTQueriedFeature fromMap:[self readValue]];
    
    case 152:     
      return [FLTRenderedQueryGeometry fromMap:[self readValue]];
    
    case 153:     
      return [FLTRenderedQueryOptions fromMap:[self readValue]];
    
    case 154:     
      return [FLTResourceOptions fromMap:[self readValue]];
    
    case 155:     
      return [FLTScreenBox fromMap:[self readValue]];
    
    case 156:     
      return [FLTScreenCoordinate fromMap:[self readValue]];
    
    case 157:     
      return [FLTSize fromMap:[self readValue]];
    
    case 158:     
      return [FLTSourceQueryOptions fromMap:[self readValue]];
    
    case 159:     
      return [FLTStyleObjectInfo fromMap:[self readValue]];
    
    case 160:     
      return [FLTStylePropertyValue fromMap:[self readValue]];
    
    case 161:     
      return [FLTTransitionOptions fromMap:[self readValue]];
    
    default:    
      return [super readValueOfType:type];
    
  }
}
@end

@interface FLT_MapInterfaceCodecWriter : FlutterStandardWriter
@end
@implementation FLT_MapInterfaceCodecWriter
- (void)writeValue:(id)value 
{
  if ([value isKindOfClass:[FLTCameraBounds class]]) {
    [self writeByte:128];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTCameraBoundsOptions class]]) {
    [self writeByte:129];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTCameraOptions class]]) {
    [self writeByte:130];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTCameraState class]]) {
    [self writeByte:131];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTCanonicalTileID class]]) {
    [self writeByte:132];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTCoordinateBounds class]]) {
    [self writeByte:133];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTCoordinateBoundsZoom class]]) {
    [self writeByte:134];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTFeatureExtensionValue class]]) {
    [self writeByte:135];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTGlyphsRasterizationOptions class]]) {
    [self writeByte:136];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTImageContent class]]) {
    [self writeByte:137];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTImageStretches class]]) {
    [self writeByte:138];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTLayerPosition class]]) {
    [self writeByte:139];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTMapAnimationOptions class]]) {
    [self writeByte:140];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTMapDebugOptions class]]) {
    [self writeByte:141];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTMapMemoryBudgetInMegabytes class]]) {
    [self writeByte:142];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTMapMemoryBudgetInTiles class]]) {
    [self writeByte:143];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTMapOptions class]]) {
    [self writeByte:144];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTMbxEdgeInsets class]]) {
    [self writeByte:145];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTMbxImage class]]) {
    [self writeByte:146];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTMercatorCoordinate class]]) {
    [self writeByte:147];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTOfflineRegionGeometryDefinition class]]) {
    [self writeByte:148];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTOfflineRegionTilePyramidDefinition class]]) {
    [self writeByte:149];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTProjectedMeters class]]) {
    [self writeByte:150];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTQueriedFeature class]]) {
    [self writeByte:151];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTRenderedQueryGeometry class]]) {
    [self writeByte:152];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTRenderedQueryOptions class]]) {
    [self writeByte:153];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTResourceOptions class]]) {
    [self writeByte:154];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTScreenBox class]]) {
    [self writeByte:155];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTScreenCoordinate class]]) {
    [self writeByte:156];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTSize class]]) {
    [self writeByte:157];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTSourceQueryOptions class]]) {
    [self writeByte:158];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTStyleObjectInfo class]]) {
    [self writeByte:159];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTStylePropertyValue class]]) {
    [self writeByte:160];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTTransitionOptions class]]) {
    [self writeByte:161];
    [self writeValue:[value toMap]];
  } else 
{
    [super writeValue:value];
  }
}
@end

@interface FLT_MapInterfaceCodecReaderWriter : FlutterStandardReaderWriter
@end
@implementation FLT_MapInterfaceCodecReaderWriter
- (FlutterStandardWriter *)writerWithData:(NSMutableData *)data {
  return [[FLT_MapInterfaceCodecWriter alloc] initWithData:data];
}
- (FlutterStandardReader *)readerWithData:(NSData *)data {
  return [[FLT_MapInterfaceCodecReader alloc] initWithData:data];
}
@end

NSObject<FlutterMessageCodec> *FLT_MapInterfaceGetCodec() {
  static dispatch_once_t sPred = 0;
  static FlutterStandardMessageCodec *sSharedObject = nil;
  dispatch_once(&sPred, ^{
    FLT_MapInterfaceCodecReaderWriter *readerWriter = [[FLT_MapInterfaceCodecReaderWriter alloc] init];
    sSharedObject = [FlutterStandardMessageCodec codecWithReaderWriter:readerWriter];
  });
  return sSharedObject;
}


void FLT_MapInterfaceSetup(id<FlutterBinaryMessenger> binaryMessenger, NSObject<FLT_MapInterface> *api) {
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon._MapInterface.loadStyleURI"
        binaryMessenger:binaryMessenger
        codec:FLT_MapInterfaceGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(loadStyleURIStyleURI:completion:)], @"FLT_MapInterface api (%@) doesn't respond to @selector(loadStyleURIStyleURI:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_styleURI = GetNullableObjectAtIndex(args, 0);
        [api loadStyleURIStyleURI:arg_styleURI completion:^(FlutterError *_Nullable error) {
          callback(wrapResult(nil, error));
        }];
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon._MapInterface.loadStyleJson"
        binaryMessenger:binaryMessenger
        codec:FLT_MapInterfaceGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(loadStyleJsonStyleJson:completion:)], @"FLT_MapInterface api (%@) doesn't respond to @selector(loadStyleJsonStyleJson:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_styleJson = GetNullableObjectAtIndex(args, 0);
        [api loadStyleJsonStyleJson:arg_styleJson completion:^(FlutterError *_Nullable error) {
          callback(wrapResult(nil, error));
        }];
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon._MapInterface.clearData"
        binaryMessenger:binaryMessenger
        codec:FLT_MapInterfaceGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(clearDataWithCompletion:)], @"FLT_MapInterface api (%@) doesn't respond to @selector(clearDataWithCompletion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        [api clearDataWithCompletion:^(FlutterError *_Nullable error) {
          callback(wrapResult(nil, error));
        }];
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon._MapInterface.setMemoryBudget"
        binaryMessenger:binaryMessenger
        codec:FLT_MapInterfaceGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(setMemoryBudgetMapMemoryBudgetInMegabytes:mapMemoryBudgetInTiles:error:)], @"FLT_MapInterface api (%@) doesn't respond to @selector(setMemoryBudgetMapMemoryBudgetInMegabytes:mapMemoryBudgetInTiles:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        FLTMapMemoryBudgetInMegabytes *arg_mapMemoryBudgetInMegabytes = GetNullableObjectAtIndex(args, 0);
        FLTMapMemoryBudgetInTiles *arg_mapMemoryBudgetInTiles = GetNullableObjectAtIndex(args, 1);
        FlutterError *error;
        [api setMemoryBudgetMapMemoryBudgetInMegabytes:arg_mapMemoryBudgetInMegabytes mapMemoryBudgetInTiles:arg_mapMemoryBudgetInTiles error:&error];
        callback(wrapResult(nil, error));
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon._MapInterface.getSize"
        binaryMessenger:binaryMessenger
        codec:FLT_MapInterfaceGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(getSizeWithError:)], @"FLT_MapInterface api (%@) doesn't respond to @selector(getSizeWithError:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        FLTSize *output = [api getSizeWithError:&error];
        callback(wrapResult(output, error));
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon._MapInterface.triggerRepaint"
        binaryMessenger:binaryMessenger
        codec:FLT_MapInterfaceGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(triggerRepaintWithError:)], @"FLT_MapInterface api (%@) doesn't respond to @selector(triggerRepaintWithError:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        [api triggerRepaintWithError:&error];
        callback(wrapResult(nil, error));
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon._MapInterface.setGestureInProgress"
        binaryMessenger:binaryMessenger
        codec:FLT_MapInterfaceGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(setGestureInProgressInProgress:error:)], @"FLT_MapInterface api (%@) doesn't respond to @selector(setGestureInProgressInProgress:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSNumber *arg_inProgress = GetNullableObjectAtIndex(args, 0);
        FlutterError *error;
        [api setGestureInProgressInProgress:arg_inProgress error:&error];
        callback(wrapResult(nil, error));
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon._MapInterface.isGestureInProgress"
        binaryMessenger:binaryMessenger
        codec:FLT_MapInterfaceGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(isGestureInProgressWithError:)], @"FLT_MapInterface api (%@) doesn't respond to @selector(isGestureInProgressWithError:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        NSNumber *output = [api isGestureInProgressWithError:&error];
        callback(wrapResult(output, error));
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon._MapInterface.setUserAnimationInProgress"
        binaryMessenger:binaryMessenger
        codec:FLT_MapInterfaceGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(setUserAnimationInProgressInProgress:error:)], @"FLT_MapInterface api (%@) doesn't respond to @selector(setUserAnimationInProgressInProgress:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSNumber *arg_inProgress = GetNullableObjectAtIndex(args, 0);
        FlutterError *error;
        [api setUserAnimationInProgressInProgress:arg_inProgress error:&error];
        callback(wrapResult(nil, error));
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon._MapInterface.isUserAnimationInProgress"
        binaryMessenger:binaryMessenger
        codec:FLT_MapInterfaceGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(isUserAnimationInProgressWithError:)], @"FLT_MapInterface api (%@) doesn't respond to @selector(isUserAnimationInProgressWithError:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        NSNumber *output = [api isUserAnimationInProgressWithError:&error];
        callback(wrapResult(output, error));
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon._MapInterface.setPrefetchZoomDelta"
        binaryMessenger:binaryMessenger
        codec:FLT_MapInterfaceGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(setPrefetchZoomDeltaDelta:error:)], @"FLT_MapInterface api (%@) doesn't respond to @selector(setPrefetchZoomDeltaDelta:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSNumber *arg_delta = GetNullableObjectAtIndex(args, 0);
        FlutterError *error;
        [api setPrefetchZoomDeltaDelta:arg_delta error:&error];
        callback(wrapResult(nil, error));
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon._MapInterface.getPrefetchZoomDelta"
        binaryMessenger:binaryMessenger
        codec:FLT_MapInterfaceGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(getPrefetchZoomDeltaWithError:)], @"FLT_MapInterface api (%@) doesn't respond to @selector(getPrefetchZoomDeltaWithError:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        NSNumber *output = [api getPrefetchZoomDeltaWithError:&error];
        callback(wrapResult(output, error));
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon._MapInterface.setNorthOrientation"
        binaryMessenger:binaryMessenger
        codec:FLT_MapInterfaceGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(setNorthOrientationOrientation:error:)], @"FLT_MapInterface api (%@) doesn't respond to @selector(setNorthOrientationOrientation:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        FLTNorthOrientation arg_orientation = [GetNullableObjectAtIndex(args, 0) integerValue];
        FlutterError *error;
        [api setNorthOrientationOrientation:arg_orientation error:&error];
        callback(wrapResult(nil, error));
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon._MapInterface.setConstrainMode"
        binaryMessenger:binaryMessenger
        codec:FLT_MapInterfaceGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(setConstrainModeMode:error:)], @"FLT_MapInterface api (%@) doesn't respond to @selector(setConstrainModeMode:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        FLTConstrainMode arg_mode = [GetNullableObjectAtIndex(args, 0) integerValue];
        FlutterError *error;
        [api setConstrainModeMode:arg_mode error:&error];
        callback(wrapResult(nil, error));
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon._MapInterface.setViewportMode"
        binaryMessenger:binaryMessenger
        codec:FLT_MapInterfaceGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(setViewportModeMode:error:)], @"FLT_MapInterface api (%@) doesn't respond to @selector(setViewportModeMode:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        FLTViewportMode arg_mode = [GetNullableObjectAtIndex(args, 0) integerValue];
        FlutterError *error;
        [api setViewportModeMode:arg_mode error:&error];
        callback(wrapResult(nil, error));
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon._MapInterface.getMapOptions"
        binaryMessenger:binaryMessenger
        codec:FLT_MapInterfaceGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(getMapOptionsWithError:)], @"FLT_MapInterface api (%@) doesn't respond to @selector(getMapOptionsWithError:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        FLTMapOptions *output = [api getMapOptionsWithError:&error];
        callback(wrapResult(output, error));
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon._MapInterface.getDebug"
        binaryMessenger:binaryMessenger
        codec:FLT_MapInterfaceGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(getDebugWithError:)], @"FLT_MapInterface api (%@) doesn't respond to @selector(getDebugWithError:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        NSArray<FLTMapDebugOptions *> *output = [api getDebugWithError:&error];
        callback(wrapResult(output, error));
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon._MapInterface.setDebug"
        binaryMessenger:binaryMessenger
        codec:FLT_MapInterfaceGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(setDebugDebugOptions:value:error:)], @"FLT_MapInterface api (%@) doesn't respond to @selector(setDebugDebugOptions:value:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSArray<FLTMapDebugOptions *> *arg_debugOptions = GetNullableObjectAtIndex(args, 0);
        NSNumber *arg_value = GetNullableObjectAtIndex(args, 1);
        FlutterError *error;
        [api setDebugDebugOptions:arg_debugOptions value:arg_value error:&error];
        callback(wrapResult(nil, error));
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon._MapInterface.queryRenderedFeatures"
        binaryMessenger:binaryMessenger
        codec:FLT_MapInterfaceGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(queryRenderedFeaturesGeometry:options:completion:)], @"FLT_MapInterface api (%@) doesn't respond to @selector(queryRenderedFeaturesGeometry:options:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        FLTRenderedQueryGeometry *arg_geometry = GetNullableObjectAtIndex(args, 0);
        FLTRenderedQueryOptions *arg_options = GetNullableObjectAtIndex(args, 1);
        [api queryRenderedFeaturesGeometry:arg_geometry options:arg_options completion:^(NSArray<FLTQueriedFeature *> *_Nullable output, FlutterError *_Nullable error) {
          callback(wrapResult(output, error));
        }];
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon._MapInterface.querySourceFeatures"
        binaryMessenger:binaryMessenger
        codec:FLT_MapInterfaceGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(querySourceFeaturesSourceId:options:completion:)], @"FLT_MapInterface api (%@) doesn't respond to @selector(querySourceFeaturesSourceId:options:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_sourceId = GetNullableObjectAtIndex(args, 0);
        FLTSourceQueryOptions *arg_options = GetNullableObjectAtIndex(args, 1);
        [api querySourceFeaturesSourceId:arg_sourceId options:arg_options completion:^(NSArray<FLTQueriedFeature *> *_Nullable output, FlutterError *_Nullable error) {
          callback(wrapResult(output, error));
        }];
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon._MapInterface.getGeoJsonClusterLeaves"
        binaryMessenger:binaryMessenger
        codec:FLT_MapInterfaceGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(getGeoJsonClusterLeavesSourceIdentifier:cluster:limit:offset:completion:)], @"FLT_MapInterface api (%@) doesn't respond to @selector(getGeoJsonClusterLeavesSourceIdentifier:cluster:limit:offset:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_sourceIdentifier = GetNullableObjectAtIndex(args, 0);
        NSDictionary<NSString *, id> *arg_cluster = GetNullableObjectAtIndex(args, 1);
        NSNumber *arg_limit = GetNullableObjectAtIndex(args, 2);
        NSNumber *arg_offset = GetNullableObjectAtIndex(args, 3);
        [api getGeoJsonClusterLeavesSourceIdentifier:arg_sourceIdentifier cluster:arg_cluster limit:arg_limit offset:arg_offset completion:^(FLTFeatureExtensionValue *_Nullable output, FlutterError *_Nullable error) {
          callback(wrapResult(output, error));
        }];
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon._MapInterface.getGeoJsonClusterChildren"
        binaryMessenger:binaryMessenger
        codec:FLT_MapInterfaceGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(getGeoJsonClusterChildrenSourceIdentifier:cluster:completion:)], @"FLT_MapInterface api (%@) doesn't respond to @selector(getGeoJsonClusterChildrenSourceIdentifier:cluster:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_sourceIdentifier = GetNullableObjectAtIndex(args, 0);
        NSDictionary<NSString *, id> *arg_cluster = GetNullableObjectAtIndex(args, 1);
        [api getGeoJsonClusterChildrenSourceIdentifier:arg_sourceIdentifier cluster:arg_cluster completion:^(FLTFeatureExtensionValue *_Nullable output, FlutterError *_Nullable error) {
          callback(wrapResult(output, error));
        }];
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon._MapInterface.getGeoJsonClusterExpansionZoom"
        binaryMessenger:binaryMessenger
        codec:FLT_MapInterfaceGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(getGeoJsonClusterExpansionZoomSourceIdentifier:cluster:completion:)], @"FLT_MapInterface api (%@) doesn't respond to @selector(getGeoJsonClusterExpansionZoomSourceIdentifier:cluster:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_sourceIdentifier = GetNullableObjectAtIndex(args, 0);
        NSDictionary<NSString *, id> *arg_cluster = GetNullableObjectAtIndex(args, 1);
        [api getGeoJsonClusterExpansionZoomSourceIdentifier:arg_sourceIdentifier cluster:arg_cluster completion:^(FLTFeatureExtensionValue *_Nullable output, FlutterError *_Nullable error) {
          callback(wrapResult(output, error));
        }];
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon._MapInterface.setFeatureState"
        binaryMessenger:binaryMessenger
        codec:FLT_MapInterfaceGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(setFeatureStateSourceId:sourceLayerId:featureId:state:error:)], @"FLT_MapInterface api (%@) doesn't respond to @selector(setFeatureStateSourceId:sourceLayerId:featureId:state:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_sourceId = GetNullableObjectAtIndex(args, 0);
        NSString *arg_sourceLayerId = GetNullableObjectAtIndex(args, 1);
        NSString *arg_featureId = GetNullableObjectAtIndex(args, 2);
        NSString *arg_state = GetNullableObjectAtIndex(args, 3);
        FlutterError *error;
        [api setFeatureStateSourceId:arg_sourceId sourceLayerId:arg_sourceLayerId featureId:arg_featureId state:arg_state error:&error];
        callback(wrapResult(nil, error));
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon._MapInterface.getFeatureState"
        binaryMessenger:binaryMessenger
        codec:FLT_MapInterfaceGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(getFeatureStateSourceId:sourceLayerId:featureId:completion:)], @"FLT_MapInterface api (%@) doesn't respond to @selector(getFeatureStateSourceId:sourceLayerId:featureId:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_sourceId = GetNullableObjectAtIndex(args, 0);
        NSString *arg_sourceLayerId = GetNullableObjectAtIndex(args, 1);
        NSString *arg_featureId = GetNullableObjectAtIndex(args, 2);
        [api getFeatureStateSourceId:arg_sourceId sourceLayerId:arg_sourceLayerId featureId:arg_featureId completion:^(NSString *_Nullable output, FlutterError *_Nullable error) {
          callback(wrapResult(output, error));
        }];
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon._MapInterface.removeFeatureState"
        binaryMessenger:binaryMessenger
        codec:FLT_MapInterfaceGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(removeFeatureStateSourceId:sourceLayerId:featureId:stateKey:error:)], @"FLT_MapInterface api (%@) doesn't respond to @selector(removeFeatureStateSourceId:sourceLayerId:featureId:stateKey:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_sourceId = GetNullableObjectAtIndex(args, 0);
        NSString *arg_sourceLayerId = GetNullableObjectAtIndex(args, 1);
        NSString *arg_featureId = GetNullableObjectAtIndex(args, 2);
        NSString *arg_stateKey = GetNullableObjectAtIndex(args, 3);
        FlutterError *error;
        [api removeFeatureStateSourceId:arg_sourceId sourceLayerId:arg_sourceLayerId featureId:arg_featureId stateKey:arg_stateKey error:&error];
        callback(wrapResult(nil, error));
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon._MapInterface.reduceMemoryUse"
        binaryMessenger:binaryMessenger
        codec:FLT_MapInterfaceGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(reduceMemoryUseWithError:)], @"FLT_MapInterface api (%@) doesn't respond to @selector(reduceMemoryUseWithError:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        [api reduceMemoryUseWithError:&error];
        callback(wrapResult(nil, error));
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon._MapInterface.getResourceOptions"
        binaryMessenger:binaryMessenger
        codec:FLT_MapInterfaceGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(getResourceOptionsWithError:)], @"FLT_MapInterface api (%@) doesn't respond to @selector(getResourceOptionsWithError:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        FLTResourceOptions *output = [api getResourceOptionsWithError:&error];
        callback(wrapResult(output, error));
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon._MapInterface.getElevation"
        binaryMessenger:binaryMessenger
        codec:FLT_MapInterfaceGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(getElevationCoordinate:error:)], @"FLT_MapInterface api (%@) doesn't respond to @selector(getElevationCoordinate:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSDictionary<NSString *, id> *arg_coordinate = GetNullableObjectAtIndex(args, 0);
        FlutterError *error;
        NSNumber *output = [api getElevationCoordinate:arg_coordinate error:&error];
        callback(wrapResult(output, error));
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
}
@interface FLTOfflineRegionCodecReader : FlutterStandardReader
@end
@implementation FLTOfflineRegionCodecReader
- (nullable id)readValueOfType:(UInt8)type 
{
  switch (type) {
    case 128:     
      return [FLTCoordinateBounds fromMap:[self readValue]];
    
    case 129:     
      return [FLTOfflineRegionGeometryDefinition fromMap:[self readValue]];
    
    case 130:     
      return [FLTOfflineRegionTilePyramidDefinition fromMap:[self readValue]];
    
    default:    
      return [super readValueOfType:type];
    
  }
}
@end

@interface FLTOfflineRegionCodecWriter : FlutterStandardWriter
@end
@implementation FLTOfflineRegionCodecWriter
- (void)writeValue:(id)value 
{
  if ([value isKindOfClass:[FLTCoordinateBounds class]]) {
    [self writeByte:128];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTOfflineRegionGeometryDefinition class]]) {
    [self writeByte:129];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTOfflineRegionTilePyramidDefinition class]]) {
    [self writeByte:130];
    [self writeValue:[value toMap]];
  } else 
{
    [super writeValue:value];
  }
}
@end

@interface FLTOfflineRegionCodecReaderWriter : FlutterStandardReaderWriter
@end
@implementation FLTOfflineRegionCodecReaderWriter
- (FlutterStandardWriter *)writerWithData:(NSMutableData *)data {
  return [[FLTOfflineRegionCodecWriter alloc] initWithData:data];
}
- (FlutterStandardReader *)readerWithData:(NSData *)data {
  return [[FLTOfflineRegionCodecReader alloc] initWithData:data];
}
@end

NSObject<FlutterMessageCodec> *FLTOfflineRegionGetCodec() {
  static dispatch_once_t sPred = 0;
  static FlutterStandardMessageCodec *sSharedObject = nil;
  dispatch_once(&sPred, ^{
    FLTOfflineRegionCodecReaderWriter *readerWriter = [[FLTOfflineRegionCodecReaderWriter alloc] init];
    sSharedObject = [FlutterStandardMessageCodec codecWithReaderWriter:readerWriter];
  });
  return sSharedObject;
}


void FLTOfflineRegionSetup(id<FlutterBinaryMessenger> binaryMessenger, NSObject<FLTOfflineRegion> *api) {
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.OfflineRegion.getIdentifier"
        binaryMessenger:binaryMessenger
        codec:FLTOfflineRegionGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(getIdentifierWithError:)], @"FLTOfflineRegion api (%@) doesn't respond to @selector(getIdentifierWithError:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        NSNumber *output = [api getIdentifierWithError:&error];
        callback(wrapResult(output, error));
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.OfflineRegion.getTilePyramidDefinition"
        binaryMessenger:binaryMessenger
        codec:FLTOfflineRegionGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(getTilePyramidDefinitionWithError:)], @"FLTOfflineRegion api (%@) doesn't respond to @selector(getTilePyramidDefinitionWithError:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        FLTOfflineRegionTilePyramidDefinition *output = [api getTilePyramidDefinitionWithError:&error];
        callback(wrapResult(output, error));
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.OfflineRegion.getGeometryDefinition"
        binaryMessenger:binaryMessenger
        codec:FLTOfflineRegionGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(getGeometryDefinitionWithError:)], @"FLTOfflineRegion api (%@) doesn't respond to @selector(getGeometryDefinitionWithError:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        FLTOfflineRegionGeometryDefinition *output = [api getGeometryDefinitionWithError:&error];
        callback(wrapResult(output, error));
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.OfflineRegion.getMetadata"
        binaryMessenger:binaryMessenger
        codec:FLTOfflineRegionGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(getMetadataWithError:)], @"FLTOfflineRegion api (%@) doesn't respond to @selector(getMetadataWithError:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        FlutterStandardTypedData *output = [api getMetadataWithError:&error];
        callback(wrapResult(output, error));
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.OfflineRegion.setMetadata"
        binaryMessenger:binaryMessenger
        codec:FLTOfflineRegionGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(setMetadataMetadata:completion:)], @"FLTOfflineRegion api (%@) doesn't respond to @selector(setMetadataMetadata:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        FlutterStandardTypedData *arg_metadata = GetNullableObjectAtIndex(args, 0);
        [api setMetadataMetadata:arg_metadata completion:^(FlutterError *_Nullable error) {
          callback(wrapResult(nil, error));
        }];
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.OfflineRegion.setOfflineRegionDownloadState"
        binaryMessenger:binaryMessenger
        codec:FLTOfflineRegionGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(setOfflineRegionDownloadStateState:error:)], @"FLTOfflineRegion api (%@) doesn't respond to @selector(setOfflineRegionDownloadStateState:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        FLTOfflineRegionDownloadState arg_state = [GetNullableObjectAtIndex(args, 0) integerValue];
        FlutterError *error;
        [api setOfflineRegionDownloadStateState:arg_state error:&error];
        callback(wrapResult(nil, error));
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.OfflineRegion.invalidate"
        binaryMessenger:binaryMessenger
        codec:FLTOfflineRegionGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(invalidateWithCompletion:)], @"FLTOfflineRegion api (%@) doesn't respond to @selector(invalidateWithCompletion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        [api invalidateWithCompletion:^(FlutterError *_Nullable error) {
          callback(wrapResult(nil, error));
        }];
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.OfflineRegion.purge"
        binaryMessenger:binaryMessenger
        codec:FLTOfflineRegionGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(purgeWithCompletion:)], @"FLTOfflineRegion api (%@) doesn't respond to @selector(purgeWithCompletion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        [api purgeWithCompletion:^(FlutterError *_Nullable error) {
          callback(wrapResult(nil, error));
        }];
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
}
@interface FLTOfflineRegionManagerCodecReader : FlutterStandardReader
@end
@implementation FLTOfflineRegionManagerCodecReader
@end

@interface FLTOfflineRegionManagerCodecWriter : FlutterStandardWriter
@end
@implementation FLTOfflineRegionManagerCodecWriter
@end

@interface FLTOfflineRegionManagerCodecReaderWriter : FlutterStandardReaderWriter
@end
@implementation FLTOfflineRegionManagerCodecReaderWriter
- (FlutterStandardWriter *)writerWithData:(NSMutableData *)data {
  return [[FLTOfflineRegionManagerCodecWriter alloc] initWithData:data];
}
- (FlutterStandardReader *)readerWithData:(NSData *)data {
  return [[FLTOfflineRegionManagerCodecReader alloc] initWithData:data];
}
@end

NSObject<FlutterMessageCodec> *FLTOfflineRegionManagerGetCodec() {
  static dispatch_once_t sPred = 0;
  static FlutterStandardMessageCodec *sSharedObject = nil;
  dispatch_once(&sPred, ^{
    FLTOfflineRegionManagerCodecReaderWriter *readerWriter = [[FLTOfflineRegionManagerCodecReaderWriter alloc] init];
    sSharedObject = [FlutterStandardMessageCodec codecWithReaderWriter:readerWriter];
  });
  return sSharedObject;
}


void FLTOfflineRegionManagerSetup(id<FlutterBinaryMessenger> binaryMessenger, NSObject<FLTOfflineRegionManager> *api) {
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.OfflineRegionManager.setOfflineMapboxTileCountLimit"
        binaryMessenger:binaryMessenger
        codec:FLTOfflineRegionManagerGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(setOfflineMapboxTileCountLimitLimit:error:)], @"FLTOfflineRegionManager api (%@) doesn't respond to @selector(setOfflineMapboxTileCountLimitLimit:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSNumber *arg_limit = GetNullableObjectAtIndex(args, 0);
        FlutterError *error;
        [api setOfflineMapboxTileCountLimitLimit:arg_limit error:&error];
        callback(wrapResult(nil, error));
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
}
@interface FLTProjectionCodecReader : FlutterStandardReader
@end
@implementation FLTProjectionCodecReader
- (nullable id)readValueOfType:(UInt8)type 
{
  switch (type) {
    case 128:     
      return [FLTCameraBounds fromMap:[self readValue]];
    
    case 129:     
      return [FLTCameraBoundsOptions fromMap:[self readValue]];
    
    case 130:     
      return [FLTCameraOptions fromMap:[self readValue]];
    
    case 131:     
      return [FLTCameraState fromMap:[self readValue]];
    
    case 132:     
      return [FLTCanonicalTileID fromMap:[self readValue]];
    
    case 133:     
      return [FLTCoordinateBounds fromMap:[self readValue]];
    
    case 134:     
      return [FLTCoordinateBoundsZoom fromMap:[self readValue]];
    
    case 135:     
      return [FLTFeatureExtensionValue fromMap:[self readValue]];
    
    case 136:     
      return [FLTGlyphsRasterizationOptions fromMap:[self readValue]];
    
    case 137:     
      return [FLTImageContent fromMap:[self readValue]];
    
    case 138:     
      return [FLTImageStretches fromMap:[self readValue]];
    
    case 139:     
      return [FLTLayerPosition fromMap:[self readValue]];
    
    case 140:     
      return [FLTMapAnimationOptions fromMap:[self readValue]];
    
    case 141:     
      return [FLTMapDebugOptions fromMap:[self readValue]];
    
    case 142:     
      return [FLTMapMemoryBudgetInMegabytes fromMap:[self readValue]];
    
    case 143:     
      return [FLTMapMemoryBudgetInTiles fromMap:[self readValue]];
    
    case 144:     
      return [FLTMapOptions fromMap:[self readValue]];
    
    case 145:     
      return [FLTMbxEdgeInsets fromMap:[self readValue]];
    
    case 146:     
      return [FLTMbxImage fromMap:[self readValue]];
    
    case 147:     
      return [FLTMercatorCoordinate fromMap:[self readValue]];
    
    case 148:     
      return [FLTOfflineRegionGeometryDefinition fromMap:[self readValue]];
    
    case 149:     
      return [FLTOfflineRegionTilePyramidDefinition fromMap:[self readValue]];
    
    case 150:     
      return [FLTProjectedMeters fromMap:[self readValue]];
    
    case 151:     
      return [FLTQueriedFeature fromMap:[self readValue]];
    
    case 152:     
      return [FLTRenderedQueryGeometry fromMap:[self readValue]];
    
    case 153:     
      return [FLTRenderedQueryOptions fromMap:[self readValue]];
    
    case 154:     
      return [FLTResourceOptions fromMap:[self readValue]];
    
    case 155:     
      return [FLTScreenBox fromMap:[self readValue]];
    
    case 156:     
      return [FLTScreenCoordinate fromMap:[self readValue]];
    
    case 157:     
      return [FLTSize fromMap:[self readValue]];
    
    case 158:     
      return [FLTSourceQueryOptions fromMap:[self readValue]];
    
    case 159:     
      return [FLTStyleObjectInfo fromMap:[self readValue]];
    
    case 160:     
      return [FLTStylePropertyValue fromMap:[self readValue]];
    
    case 161:     
      return [FLTTransitionOptions fromMap:[self readValue]];
    
    default:    
      return [super readValueOfType:type];
    
  }
}
@end

@interface FLTProjectionCodecWriter : FlutterStandardWriter
@end
@implementation FLTProjectionCodecWriter
- (void)writeValue:(id)value 
{
  if ([value isKindOfClass:[FLTCameraBounds class]]) {
    [self writeByte:128];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTCameraBoundsOptions class]]) {
    [self writeByte:129];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTCameraOptions class]]) {
    [self writeByte:130];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTCameraState class]]) {
    [self writeByte:131];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTCanonicalTileID class]]) {
    [self writeByte:132];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTCoordinateBounds class]]) {
    [self writeByte:133];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTCoordinateBoundsZoom class]]) {
    [self writeByte:134];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTFeatureExtensionValue class]]) {
    [self writeByte:135];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTGlyphsRasterizationOptions class]]) {
    [self writeByte:136];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTImageContent class]]) {
    [self writeByte:137];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTImageStretches class]]) {
    [self writeByte:138];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTLayerPosition class]]) {
    [self writeByte:139];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTMapAnimationOptions class]]) {
    [self writeByte:140];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTMapDebugOptions class]]) {
    [self writeByte:141];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTMapMemoryBudgetInMegabytes class]]) {
    [self writeByte:142];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTMapMemoryBudgetInTiles class]]) {
    [self writeByte:143];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTMapOptions class]]) {
    [self writeByte:144];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTMbxEdgeInsets class]]) {
    [self writeByte:145];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTMbxImage class]]) {
    [self writeByte:146];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTMercatorCoordinate class]]) {
    [self writeByte:147];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTOfflineRegionGeometryDefinition class]]) {
    [self writeByte:148];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTOfflineRegionTilePyramidDefinition class]]) {
    [self writeByte:149];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTProjectedMeters class]]) {
    [self writeByte:150];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTQueriedFeature class]]) {
    [self writeByte:151];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTRenderedQueryGeometry class]]) {
    [self writeByte:152];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTRenderedQueryOptions class]]) {
    [self writeByte:153];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTResourceOptions class]]) {
    [self writeByte:154];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTScreenBox class]]) {
    [self writeByte:155];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTScreenCoordinate class]]) {
    [self writeByte:156];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTSize class]]) {
    [self writeByte:157];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTSourceQueryOptions class]]) {
    [self writeByte:158];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTStyleObjectInfo class]]) {
    [self writeByte:159];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTStylePropertyValue class]]) {
    [self writeByte:160];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTTransitionOptions class]]) {
    [self writeByte:161];
    [self writeValue:[value toMap]];
  } else 
{
    [super writeValue:value];
  }
}
@end

@interface FLTProjectionCodecReaderWriter : FlutterStandardReaderWriter
@end
@implementation FLTProjectionCodecReaderWriter
- (FlutterStandardWriter *)writerWithData:(NSMutableData *)data {
  return [[FLTProjectionCodecWriter alloc] initWithData:data];
}
- (FlutterStandardReader *)readerWithData:(NSData *)data {
  return [[FLTProjectionCodecReader alloc] initWithData:data];
}
@end

NSObject<FlutterMessageCodec> *FLTProjectionGetCodec() {
  static dispatch_once_t sPred = 0;
  static FlutterStandardMessageCodec *sSharedObject = nil;
  dispatch_once(&sPred, ^{
    FLTProjectionCodecReaderWriter *readerWriter = [[FLTProjectionCodecReaderWriter alloc] init];
    sSharedObject = [FlutterStandardMessageCodec codecWithReaderWriter:readerWriter];
  });
  return sSharedObject;
}


void FLTProjectionSetup(id<FlutterBinaryMessenger> binaryMessenger, NSObject<FLTProjection> *api) {
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.Projection.getMetersPerPixelAtLatitude"
        binaryMessenger:binaryMessenger
        codec:FLTProjectionGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(getMetersPerPixelAtLatitudeLatitude:zoom:error:)], @"FLTProjection api (%@) doesn't respond to @selector(getMetersPerPixelAtLatitudeLatitude:zoom:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSNumber *arg_latitude = GetNullableObjectAtIndex(args, 0);
        NSNumber *arg_zoom = GetNullableObjectAtIndex(args, 1);
        FlutterError *error;
        NSNumber *output = [api getMetersPerPixelAtLatitudeLatitude:arg_latitude zoom:arg_zoom error:&error];
        callback(wrapResult(output, error));
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.Projection.projectedMetersForCoordinate"
        binaryMessenger:binaryMessenger
        codec:FLTProjectionGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(projectedMetersForCoordinateCoordinate:error:)], @"FLTProjection api (%@) doesn't respond to @selector(projectedMetersForCoordinateCoordinate:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSDictionary<NSString *, id> *arg_coordinate = GetNullableObjectAtIndex(args, 0);
        FlutterError *error;
        FLTProjectedMeters *output = [api projectedMetersForCoordinateCoordinate:arg_coordinate error:&error];
        callback(wrapResult(output, error));
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.Projection.coordinateForProjectedMeters"
        binaryMessenger:binaryMessenger
        codec:FLTProjectionGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(coordinateForProjectedMetersProjectedMeters:error:)], @"FLTProjection api (%@) doesn't respond to @selector(coordinateForProjectedMetersProjectedMeters:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        FLTProjectedMeters *arg_projectedMeters = GetNullableObjectAtIndex(args, 0);
        FlutterError *error;
        NSDictionary<NSString *, id> *output = [api coordinateForProjectedMetersProjectedMeters:arg_projectedMeters error:&error];
        callback(wrapResult(output, error));
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.Projection.project"
        binaryMessenger:binaryMessenger
        codec:FLTProjectionGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(projectCoordinate:zoomScale:error:)], @"FLTProjection api (%@) doesn't respond to @selector(projectCoordinate:zoomScale:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSDictionary<NSString *, id> *arg_coordinate = GetNullableObjectAtIndex(args, 0);
        NSNumber *arg_zoomScale = GetNullableObjectAtIndex(args, 1);
        FlutterError *error;
        FLTMercatorCoordinate *output = [api projectCoordinate:arg_coordinate zoomScale:arg_zoomScale error:&error];
        callback(wrapResult(output, error));
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.Projection.unproject"
        binaryMessenger:binaryMessenger
        codec:FLTProjectionGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(unprojectCoordinate:zoomScale:error:)], @"FLTProjection api (%@) doesn't respond to @selector(unprojectCoordinate:zoomScale:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        FLTMercatorCoordinate *arg_coordinate = GetNullableObjectAtIndex(args, 0);
        NSNumber *arg_zoomScale = GetNullableObjectAtIndex(args, 1);
        FlutterError *error;
        NSDictionary<NSString *, id> *output = [api unprojectCoordinate:arg_coordinate zoomScale:arg_zoomScale error:&error];
        callback(wrapResult(output, error));
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
}
@interface FLTSettingsCodecReader : FlutterStandardReader
@end
@implementation FLTSettingsCodecReader
@end

@interface FLTSettingsCodecWriter : FlutterStandardWriter
@end
@implementation FLTSettingsCodecWriter
@end

@interface FLTSettingsCodecReaderWriter : FlutterStandardReaderWriter
@end
@implementation FLTSettingsCodecReaderWriter
- (FlutterStandardWriter *)writerWithData:(NSMutableData *)data {
  return [[FLTSettingsCodecWriter alloc] initWithData:data];
}
- (FlutterStandardReader *)readerWithData:(NSData *)data {
  return [[FLTSettingsCodecReader alloc] initWithData:data];
}
@end

NSObject<FlutterMessageCodec> *FLTSettingsGetCodec() {
  static dispatch_once_t sPred = 0;
  static FlutterStandardMessageCodec *sSharedObject = nil;
  dispatch_once(&sPred, ^{
    FLTSettingsCodecReaderWriter *readerWriter = [[FLTSettingsCodecReaderWriter alloc] init];
    sSharedObject = [FlutterStandardMessageCodec codecWithReaderWriter:readerWriter];
  });
  return sSharedObject;
}


void FLTSettingsSetup(id<FlutterBinaryMessenger> binaryMessenger, NSObject<FLTSettings> *api) {
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.Settings.set"
        binaryMessenger:binaryMessenger
        codec:FLTSettingsGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(setKey:value:error:)], @"FLTSettings api (%@) doesn't respond to @selector(setKey:value:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_key = GetNullableObjectAtIndex(args, 0);
        NSString *arg_value = GetNullableObjectAtIndex(args, 1);
        FlutterError *error;
        [api setKey:arg_key value:arg_value error:&error];
        callback(wrapResult(nil, error));
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.Settings.get"
        binaryMessenger:binaryMessenger
        codec:FLTSettingsGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(getKey:error:)], @"FLTSettings api (%@) doesn't respond to @selector(getKey:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_key = GetNullableObjectAtIndex(args, 0);
        FlutterError *error;
        NSString *output = [api getKey:arg_key error:&error];
        callback(wrapResult(output, error));
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
}
@interface FLTMapSnapshotCodecReader : FlutterStandardReader
@end
@implementation FLTMapSnapshotCodecReader
- (nullable id)readValueOfType:(UInt8)type 
{
  switch (type) {
    case 128:     
      return [FLTCameraBounds fromMap:[self readValue]];
    
    case 129:     
      return [FLTCameraBoundsOptions fromMap:[self readValue]];
    
    case 130:     
      return [FLTCameraOptions fromMap:[self readValue]];
    
    case 131:     
      return [FLTCameraState fromMap:[self readValue]];
    
    case 132:     
      return [FLTCanonicalTileID fromMap:[self readValue]];
    
    case 133:     
      return [FLTCoordinateBounds fromMap:[self readValue]];
    
    case 134:     
      return [FLTCoordinateBoundsZoom fromMap:[self readValue]];
    
    case 135:     
      return [FLTFeatureExtensionValue fromMap:[self readValue]];
    
    case 136:     
      return [FLTGlyphsRasterizationOptions fromMap:[self readValue]];
    
    case 137:     
      return [FLTImageContent fromMap:[self readValue]];
    
    case 138:     
      return [FLTImageStretches fromMap:[self readValue]];
    
    case 139:     
      return [FLTLayerPosition fromMap:[self readValue]];
    
    case 140:     
      return [FLTMapAnimationOptions fromMap:[self readValue]];
    
    case 141:     
      return [FLTMapDebugOptions fromMap:[self readValue]];
    
    case 142:     
      return [FLTMapMemoryBudgetInMegabytes fromMap:[self readValue]];
    
    case 143:     
      return [FLTMapMemoryBudgetInTiles fromMap:[self readValue]];
    
    case 144:     
      return [FLTMapOptions fromMap:[self readValue]];
    
    case 145:     
      return [FLTMbxEdgeInsets fromMap:[self readValue]];
    
    case 146:     
      return [FLTMbxImage fromMap:[self readValue]];
    
    case 147:     
      return [FLTMercatorCoordinate fromMap:[self readValue]];
    
    case 148:     
      return [FLTOfflineRegionGeometryDefinition fromMap:[self readValue]];
    
    case 149:     
      return [FLTOfflineRegionTilePyramidDefinition fromMap:[self readValue]];
    
    case 150:     
      return [FLTProjectedMeters fromMap:[self readValue]];
    
    case 151:     
      return [FLTQueriedFeature fromMap:[self readValue]];
    
    case 152:     
      return [FLTRenderedQueryGeometry fromMap:[self readValue]];
    
    case 153:     
      return [FLTRenderedQueryOptions fromMap:[self readValue]];
    
    case 154:     
      return [FLTResourceOptions fromMap:[self readValue]];
    
    case 155:     
      return [FLTScreenBox fromMap:[self readValue]];
    
    case 156:     
      return [FLTScreenCoordinate fromMap:[self readValue]];
    
    case 157:     
      return [FLTSize fromMap:[self readValue]];
    
    case 158:     
      return [FLTSourceQueryOptions fromMap:[self readValue]];
    
    case 159:     
      return [FLTStyleObjectInfo fromMap:[self readValue]];
    
    case 160:     
      return [FLTStylePropertyValue fromMap:[self readValue]];
    
    case 161:     
      return [FLTTransitionOptions fromMap:[self readValue]];
    
    default:    
      return [super readValueOfType:type];
    
  }
}
@end

@interface FLTMapSnapshotCodecWriter : FlutterStandardWriter
@end
@implementation FLTMapSnapshotCodecWriter
- (void)writeValue:(id)value 
{
  if ([value isKindOfClass:[FLTCameraBounds class]]) {
    [self writeByte:128];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTCameraBoundsOptions class]]) {
    [self writeByte:129];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTCameraOptions class]]) {
    [self writeByte:130];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTCameraState class]]) {
    [self writeByte:131];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTCanonicalTileID class]]) {
    [self writeByte:132];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTCoordinateBounds class]]) {
    [self writeByte:133];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTCoordinateBoundsZoom class]]) {
    [self writeByte:134];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTFeatureExtensionValue class]]) {
    [self writeByte:135];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTGlyphsRasterizationOptions class]]) {
    [self writeByte:136];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTImageContent class]]) {
    [self writeByte:137];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTImageStretches class]]) {
    [self writeByte:138];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTLayerPosition class]]) {
    [self writeByte:139];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTMapAnimationOptions class]]) {
    [self writeByte:140];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTMapDebugOptions class]]) {
    [self writeByte:141];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTMapMemoryBudgetInMegabytes class]]) {
    [self writeByte:142];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTMapMemoryBudgetInTiles class]]) {
    [self writeByte:143];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTMapOptions class]]) {
    [self writeByte:144];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTMbxEdgeInsets class]]) {
    [self writeByte:145];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTMbxImage class]]) {
    [self writeByte:146];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTMercatorCoordinate class]]) {
    [self writeByte:147];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTOfflineRegionGeometryDefinition class]]) {
    [self writeByte:148];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTOfflineRegionTilePyramidDefinition class]]) {
    [self writeByte:149];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTProjectedMeters class]]) {
    [self writeByte:150];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTQueriedFeature class]]) {
    [self writeByte:151];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTRenderedQueryGeometry class]]) {
    [self writeByte:152];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTRenderedQueryOptions class]]) {
    [self writeByte:153];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTResourceOptions class]]) {
    [self writeByte:154];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTScreenBox class]]) {
    [self writeByte:155];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTScreenCoordinate class]]) {
    [self writeByte:156];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTSize class]]) {
    [self writeByte:157];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTSourceQueryOptions class]]) {
    [self writeByte:158];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTStyleObjectInfo class]]) {
    [self writeByte:159];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTStylePropertyValue class]]) {
    [self writeByte:160];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTTransitionOptions class]]) {
    [self writeByte:161];
    [self writeValue:[value toMap]];
  } else 
{
    [super writeValue:value];
  }
}
@end

@interface FLTMapSnapshotCodecReaderWriter : FlutterStandardReaderWriter
@end
@implementation FLTMapSnapshotCodecReaderWriter
- (FlutterStandardWriter *)writerWithData:(NSMutableData *)data {
  return [[FLTMapSnapshotCodecWriter alloc] initWithData:data];
}
- (FlutterStandardReader *)readerWithData:(NSData *)data {
  return [[FLTMapSnapshotCodecReader alloc] initWithData:data];
}
@end

NSObject<FlutterMessageCodec> *FLTMapSnapshotGetCodec() {
  static dispatch_once_t sPred = 0;
  static FlutterStandardMessageCodec *sSharedObject = nil;
  dispatch_once(&sPred, ^{
    FLTMapSnapshotCodecReaderWriter *readerWriter = [[FLTMapSnapshotCodecReaderWriter alloc] init];
    sSharedObject = [FlutterStandardMessageCodec codecWithReaderWriter:readerWriter];
  });
  return sSharedObject;
}


void FLTMapSnapshotSetup(id<FlutterBinaryMessenger> binaryMessenger, NSObject<FLTMapSnapshot> *api) {
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.MapSnapshot.screenCoordinate"
        binaryMessenger:binaryMessenger
        codec:FLTMapSnapshotGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(screenCoordinateCoordinate:error:)], @"FLTMapSnapshot api (%@) doesn't respond to @selector(screenCoordinateCoordinate:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSDictionary<NSString *, id> *arg_coordinate = GetNullableObjectAtIndex(args, 0);
        FlutterError *error;
        FLTScreenCoordinate *output = [api screenCoordinateCoordinate:arg_coordinate error:&error];
        callback(wrapResult(output, error));
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.MapSnapshot.coordinate"
        binaryMessenger:binaryMessenger
        codec:FLTMapSnapshotGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(coordinateScreenCoordinate:error:)], @"FLTMapSnapshot api (%@) doesn't respond to @selector(coordinateScreenCoordinate:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        FLTScreenCoordinate *arg_screenCoordinate = GetNullableObjectAtIndex(args, 0);
        FlutterError *error;
        NSDictionary<NSString *, id> *output = [api coordinateScreenCoordinate:arg_screenCoordinate error:&error];
        callback(wrapResult(output, error));
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.MapSnapshot.attributions"
        binaryMessenger:binaryMessenger
        codec:FLTMapSnapshotGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(attributionsWithError:)], @"FLTMapSnapshot api (%@) doesn't respond to @selector(attributionsWithError:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        NSArray<NSString *> *output = [api attributionsWithError:&error];
        callback(wrapResult(output, error));
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.MapSnapshot.image"
        binaryMessenger:binaryMessenger
        codec:FLTMapSnapshotGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(imageWithError:)], @"FLTMapSnapshot api (%@) doesn't respond to @selector(imageWithError:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        FLTMbxImage *output = [api imageWithError:&error];
        callback(wrapResult(output, error));
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
}
@interface FLTMapSnapshotterCodecReader : FlutterStandardReader
@end
@implementation FLTMapSnapshotterCodecReader
- (nullable id)readValueOfType:(UInt8)type 
{
  switch (type) {
    case 128:     
      return [FLTCameraBounds fromMap:[self readValue]];
    
    case 129:     
      return [FLTCameraBoundsOptions fromMap:[self readValue]];
    
    case 130:     
      return [FLTCameraOptions fromMap:[self readValue]];
    
    case 131:     
      return [FLTCameraState fromMap:[self readValue]];
    
    case 132:     
      return [FLTCanonicalTileID fromMap:[self readValue]];
    
    case 133:     
      return [FLTCoordinateBounds fromMap:[self readValue]];
    
    case 134:     
      return [FLTCoordinateBoundsZoom fromMap:[self readValue]];
    
    case 135:     
      return [FLTFeatureExtensionValue fromMap:[self readValue]];
    
    case 136:     
      return [FLTGlyphsRasterizationOptions fromMap:[self readValue]];
    
    case 137:     
      return [FLTImageContent fromMap:[self readValue]];
    
    case 138:     
      return [FLTImageStretches fromMap:[self readValue]];
    
    case 139:     
      return [FLTLayerPosition fromMap:[self readValue]];
    
    case 140:     
      return [FLTMapAnimationOptions fromMap:[self readValue]];
    
    case 141:     
      return [FLTMapDebugOptions fromMap:[self readValue]];
    
    case 142:     
      return [FLTMapMemoryBudgetInMegabytes fromMap:[self readValue]];
    
    case 143:     
      return [FLTMapMemoryBudgetInTiles fromMap:[self readValue]];
    
    case 144:     
      return [FLTMapOptions fromMap:[self readValue]];
    
    case 145:     
      return [FLTMbxEdgeInsets fromMap:[self readValue]];
    
    case 146:     
      return [FLTMbxImage fromMap:[self readValue]];
    
    case 147:     
      return [FLTMercatorCoordinate fromMap:[self readValue]];
    
    case 148:     
      return [FLTOfflineRegionGeometryDefinition fromMap:[self readValue]];
    
    case 149:     
      return [FLTOfflineRegionTilePyramidDefinition fromMap:[self readValue]];
    
    case 150:     
      return [FLTProjectedMeters fromMap:[self readValue]];
    
    case 151:     
      return [FLTQueriedFeature fromMap:[self readValue]];
    
    case 152:     
      return [FLTRenderedQueryGeometry fromMap:[self readValue]];
    
    case 153:     
      return [FLTRenderedQueryOptions fromMap:[self readValue]];
    
    case 154:     
      return [FLTResourceOptions fromMap:[self readValue]];
    
    case 155:     
      return [FLTScreenBox fromMap:[self readValue]];
    
    case 156:     
      return [FLTScreenCoordinate fromMap:[self readValue]];
    
    case 157:     
      return [FLTSize fromMap:[self readValue]];
    
    case 158:     
      return [FLTSourceQueryOptions fromMap:[self readValue]];
    
    case 159:     
      return [FLTStyleObjectInfo fromMap:[self readValue]];
    
    case 160:     
      return [FLTStylePropertyValue fromMap:[self readValue]];
    
    case 161:     
      return [FLTTransitionOptions fromMap:[self readValue]];
    
    default:    
      return [super readValueOfType:type];
    
  }
}
@end

@interface FLTMapSnapshotterCodecWriter : FlutterStandardWriter
@end
@implementation FLTMapSnapshotterCodecWriter
- (void)writeValue:(id)value 
{
  if ([value isKindOfClass:[FLTCameraBounds class]]) {
    [self writeByte:128];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTCameraBoundsOptions class]]) {
    [self writeByte:129];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTCameraOptions class]]) {
    [self writeByte:130];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTCameraState class]]) {
    [self writeByte:131];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTCanonicalTileID class]]) {
    [self writeByte:132];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTCoordinateBounds class]]) {
    [self writeByte:133];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTCoordinateBoundsZoom class]]) {
    [self writeByte:134];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTFeatureExtensionValue class]]) {
    [self writeByte:135];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTGlyphsRasterizationOptions class]]) {
    [self writeByte:136];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTImageContent class]]) {
    [self writeByte:137];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTImageStretches class]]) {
    [self writeByte:138];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTLayerPosition class]]) {
    [self writeByte:139];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTMapAnimationOptions class]]) {
    [self writeByte:140];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTMapDebugOptions class]]) {
    [self writeByte:141];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTMapMemoryBudgetInMegabytes class]]) {
    [self writeByte:142];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTMapMemoryBudgetInTiles class]]) {
    [self writeByte:143];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTMapOptions class]]) {
    [self writeByte:144];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTMbxEdgeInsets class]]) {
    [self writeByte:145];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTMbxImage class]]) {
    [self writeByte:146];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTMercatorCoordinate class]]) {
    [self writeByte:147];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTOfflineRegionGeometryDefinition class]]) {
    [self writeByte:148];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTOfflineRegionTilePyramidDefinition class]]) {
    [self writeByte:149];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTProjectedMeters class]]) {
    [self writeByte:150];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTQueriedFeature class]]) {
    [self writeByte:151];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTRenderedQueryGeometry class]]) {
    [self writeByte:152];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTRenderedQueryOptions class]]) {
    [self writeByte:153];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTResourceOptions class]]) {
    [self writeByte:154];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTScreenBox class]]) {
    [self writeByte:155];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTScreenCoordinate class]]) {
    [self writeByte:156];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTSize class]]) {
    [self writeByte:157];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTSourceQueryOptions class]]) {
    [self writeByte:158];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTStyleObjectInfo class]]) {
    [self writeByte:159];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTStylePropertyValue class]]) {
    [self writeByte:160];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTTransitionOptions class]]) {
    [self writeByte:161];
    [self writeValue:[value toMap]];
  } else 
{
    [super writeValue:value];
  }
}
@end

@interface FLTMapSnapshotterCodecReaderWriter : FlutterStandardReaderWriter
@end
@implementation FLTMapSnapshotterCodecReaderWriter
- (FlutterStandardWriter *)writerWithData:(NSMutableData *)data {
  return [[FLTMapSnapshotterCodecWriter alloc] initWithData:data];
}
- (FlutterStandardReader *)readerWithData:(NSData *)data {
  return [[FLTMapSnapshotterCodecReader alloc] initWithData:data];
}
@end

NSObject<FlutterMessageCodec> *FLTMapSnapshotterGetCodec() {
  static dispatch_once_t sPred = 0;
  static FlutterStandardMessageCodec *sSharedObject = nil;
  dispatch_once(&sPred, ^{
    FLTMapSnapshotterCodecReaderWriter *readerWriter = [[FLTMapSnapshotterCodecReaderWriter alloc] init];
    sSharedObject = [FlutterStandardMessageCodec codecWithReaderWriter:readerWriter];
  });
  return sSharedObject;
}


void FLTMapSnapshotterSetup(id<FlutterBinaryMessenger> binaryMessenger, NSObject<FLTMapSnapshotter> *api) {
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.MapSnapshotter.setSize"
        binaryMessenger:binaryMessenger
        codec:FLTMapSnapshotterGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(setSizeSize:error:)], @"FLTMapSnapshotter api (%@) doesn't respond to @selector(setSizeSize:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        FLTSize *arg_size = GetNullableObjectAtIndex(args, 0);
        FlutterError *error;
        [api setSizeSize:arg_size error:&error];
        callback(wrapResult(nil, error));
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.MapSnapshotter.getSize"
        binaryMessenger:binaryMessenger
        codec:FLTMapSnapshotterGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(getSizeWithError:)], @"FLTMapSnapshotter api (%@) doesn't respond to @selector(getSizeWithError:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        FLTSize *output = [api getSizeWithError:&error];
        callback(wrapResult(output, error));
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.MapSnapshotter.isInTileMode"
        binaryMessenger:binaryMessenger
        codec:FLTMapSnapshotterGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(isInTileModeWithError:)], @"FLTMapSnapshotter api (%@) doesn't respond to @selector(isInTileModeWithError:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        NSNumber *output = [api isInTileModeWithError:&error];
        callback(wrapResult(output, error));
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.MapSnapshotter.setTileMode"
        binaryMessenger:binaryMessenger
        codec:FLTMapSnapshotterGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(setTileModeSet:error:)], @"FLTMapSnapshotter api (%@) doesn't respond to @selector(setTileModeSet:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSNumber *arg_set = GetNullableObjectAtIndex(args, 0);
        FlutterError *error;
        [api setTileModeSet:arg_set error:&error];
        callback(wrapResult(nil, error));
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.MapSnapshotter.cancel"
        binaryMessenger:binaryMessenger
        codec:FLTMapSnapshotterGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(cancelWithError:)], @"FLTMapSnapshotter api (%@) doesn't respond to @selector(cancelWithError:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        [api cancelWithError:&error];
        callback(wrapResult(nil, error));
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.MapSnapshotter.getElevation"
        binaryMessenger:binaryMessenger
        codec:FLTMapSnapshotterGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(getElevationCoordinate:error:)], @"FLTMapSnapshotter api (%@) doesn't respond to @selector(getElevationCoordinate:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSDictionary<NSString *, id> *arg_coordinate = GetNullableObjectAtIndex(args, 0);
        FlutterError *error;
        NSNumber *output = [api getElevationCoordinate:arg_coordinate error:&error];
        callback(wrapResult(output, error));
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
}
@interface FLTStyleManagerCodecReader : FlutterStandardReader
@end
@implementation FLTStyleManagerCodecReader
- (nullable id)readValueOfType:(UInt8)type 
{
  switch (type) {
    case 128:     
      return [FLTCameraBounds fromMap:[self readValue]];
    
    case 129:     
      return [FLTCameraBoundsOptions fromMap:[self readValue]];
    
    case 130:     
      return [FLTCameraOptions fromMap:[self readValue]];
    
    case 131:     
      return [FLTCameraState fromMap:[self readValue]];
    
    case 132:     
      return [FLTCanonicalTileID fromMap:[self readValue]];
    
    case 133:     
      return [FLTCoordinateBounds fromMap:[self readValue]];
    
    case 134:     
      return [FLTCoordinateBoundsZoom fromMap:[self readValue]];
    
    case 135:     
      return [FLTFeatureExtensionValue fromMap:[self readValue]];
    
    case 136:     
      return [FLTGlyphsRasterizationOptions fromMap:[self readValue]];
    
    case 137:     
      return [FLTImageContent fromMap:[self readValue]];
    
    case 138:     
      return [FLTImageStretches fromMap:[self readValue]];
    
    case 139:     
      return [FLTLayerPosition fromMap:[self readValue]];
    
    case 140:     
      return [FLTMapAnimationOptions fromMap:[self readValue]];
    
    case 141:     
      return [FLTMapDebugOptions fromMap:[self readValue]];
    
    case 142:     
      return [FLTMapMemoryBudgetInMegabytes fromMap:[self readValue]];
    
    case 143:     
      return [FLTMapMemoryBudgetInTiles fromMap:[self readValue]];
    
    case 144:     
      return [FLTMapOptions fromMap:[self readValue]];
    
    case 145:     
      return [FLTMbxEdgeInsets fromMap:[self readValue]];
    
    case 146:     
      return [FLTMbxImage fromMap:[self readValue]];
    
    case 147:     
      return [FLTMercatorCoordinate fromMap:[self readValue]];
    
    case 148:     
      return [FLTOfflineRegionGeometryDefinition fromMap:[self readValue]];
    
    case 149:     
      return [FLTOfflineRegionTilePyramidDefinition fromMap:[self readValue]];
    
    case 150:     
      return [FLTProjectedMeters fromMap:[self readValue]];
    
    case 151:     
      return [FLTQueriedFeature fromMap:[self readValue]];
    
    case 152:     
      return [FLTRenderedQueryGeometry fromMap:[self readValue]];
    
    case 153:     
      return [FLTRenderedQueryOptions fromMap:[self readValue]];
    
    case 154:     
      return [FLTResourceOptions fromMap:[self readValue]];
    
    case 155:     
      return [FLTScreenBox fromMap:[self readValue]];
    
    case 156:     
      return [FLTScreenCoordinate fromMap:[self readValue]];
    
    case 157:     
      return [FLTSize fromMap:[self readValue]];
    
    case 158:     
      return [FLTSourceQueryOptions fromMap:[self readValue]];
    
    case 159:     
      return [FLTStyleObjectInfo fromMap:[self readValue]];
    
    case 160:     
      return [FLTStylePropertyValue fromMap:[self readValue]];
    
    case 161:     
      return [FLTTransitionOptions fromMap:[self readValue]];
    
    default:    
      return [super readValueOfType:type];
    
  }
}
@end

@interface FLTStyleManagerCodecWriter : FlutterStandardWriter
@end
@implementation FLTStyleManagerCodecWriter
- (void)writeValue:(id)value 
{
  if ([value isKindOfClass:[FLTCameraBounds class]]) {
    [self writeByte:128];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTCameraBoundsOptions class]]) {
    [self writeByte:129];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTCameraOptions class]]) {
    [self writeByte:130];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTCameraState class]]) {
    [self writeByte:131];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTCanonicalTileID class]]) {
    [self writeByte:132];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTCoordinateBounds class]]) {
    [self writeByte:133];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTCoordinateBoundsZoom class]]) {
    [self writeByte:134];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTFeatureExtensionValue class]]) {
    [self writeByte:135];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTGlyphsRasterizationOptions class]]) {
    [self writeByte:136];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTImageContent class]]) {
    [self writeByte:137];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTImageStretches class]]) {
    [self writeByte:138];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTLayerPosition class]]) {
    [self writeByte:139];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTMapAnimationOptions class]]) {
    [self writeByte:140];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTMapDebugOptions class]]) {
    [self writeByte:141];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTMapMemoryBudgetInMegabytes class]]) {
    [self writeByte:142];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTMapMemoryBudgetInTiles class]]) {
    [self writeByte:143];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTMapOptions class]]) {
    [self writeByte:144];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTMbxEdgeInsets class]]) {
    [self writeByte:145];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTMbxImage class]]) {
    [self writeByte:146];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTMercatorCoordinate class]]) {
    [self writeByte:147];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTOfflineRegionGeometryDefinition class]]) {
    [self writeByte:148];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTOfflineRegionTilePyramidDefinition class]]) {
    [self writeByte:149];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTProjectedMeters class]]) {
    [self writeByte:150];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTQueriedFeature class]]) {
    [self writeByte:151];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTRenderedQueryGeometry class]]) {
    [self writeByte:152];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTRenderedQueryOptions class]]) {
    [self writeByte:153];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTResourceOptions class]]) {
    [self writeByte:154];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTScreenBox class]]) {
    [self writeByte:155];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTScreenCoordinate class]]) {
    [self writeByte:156];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTSize class]]) {
    [self writeByte:157];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTSourceQueryOptions class]]) {
    [self writeByte:158];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTStyleObjectInfo class]]) {
    [self writeByte:159];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTStylePropertyValue class]]) {
    [self writeByte:160];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[FLTTransitionOptions class]]) {
    [self writeByte:161];
    [self writeValue:[value toMap]];
  } else 
{
    [super writeValue:value];
  }
}
@end

@interface FLTStyleManagerCodecReaderWriter : FlutterStandardReaderWriter
@end
@implementation FLTStyleManagerCodecReaderWriter
- (FlutterStandardWriter *)writerWithData:(NSMutableData *)data {
  return [[FLTStyleManagerCodecWriter alloc] initWithData:data];
}
- (FlutterStandardReader *)readerWithData:(NSData *)data {
  return [[FLTStyleManagerCodecReader alloc] initWithData:data];
}
@end

NSObject<FlutterMessageCodec> *FLTStyleManagerGetCodec() {
  static dispatch_once_t sPred = 0;
  static FlutterStandardMessageCodec *sSharedObject = nil;
  dispatch_once(&sPred, ^{
    FLTStyleManagerCodecReaderWriter *readerWriter = [[FLTStyleManagerCodecReaderWriter alloc] init];
    sSharedObject = [FlutterStandardMessageCodec codecWithReaderWriter:readerWriter];
  });
  return sSharedObject;
}


void FLTStyleManagerSetup(id<FlutterBinaryMessenger> binaryMessenger, NSObject<FLTStyleManager> *api) {
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.StyleManager.getStyleURI"
        binaryMessenger:binaryMessenger
        codec:FLTStyleManagerGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(getStyleURIWithCompletion:)], @"FLTStyleManager api (%@) doesn't respond to @selector(getStyleURIWithCompletion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        [api getStyleURIWithCompletion:^(NSString *_Nullable output, FlutterError *_Nullable error) {
          callback(wrapResult(output, error));
        }];
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.StyleManager.setStyleURI"
        binaryMessenger:binaryMessenger
        codec:FLTStyleManagerGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(setStyleURIUri:completion:)], @"FLTStyleManager api (%@) doesn't respond to @selector(setStyleURIUri:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_uri = GetNullableObjectAtIndex(args, 0);
        [api setStyleURIUri:arg_uri completion:^(FlutterError *_Nullable error) {
          callback(wrapResult(nil, error));
        }];
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.StyleManager.getStyleJSON"
        binaryMessenger:binaryMessenger
        codec:FLTStyleManagerGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(getStyleJSONWithCompletion:)], @"FLTStyleManager api (%@) doesn't respond to @selector(getStyleJSONWithCompletion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        [api getStyleJSONWithCompletion:^(NSString *_Nullable output, FlutterError *_Nullable error) {
          callback(wrapResult(output, error));
        }];
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.StyleManager.setStyleJSON"
        binaryMessenger:binaryMessenger
        codec:FLTStyleManagerGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(setStyleJSONJson:completion:)], @"FLTStyleManager api (%@) doesn't respond to @selector(setStyleJSONJson:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_json = GetNullableObjectAtIndex(args, 0);
        [api setStyleJSONJson:arg_json completion:^(FlutterError *_Nullable error) {
          callback(wrapResult(nil, error));
        }];
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.StyleManager.getStyleDefaultCamera"
        binaryMessenger:binaryMessenger
        codec:FLTStyleManagerGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(getStyleDefaultCameraWithCompletion:)], @"FLTStyleManager api (%@) doesn't respond to @selector(getStyleDefaultCameraWithCompletion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        [api getStyleDefaultCameraWithCompletion:^(FLTCameraOptions *_Nullable output, FlutterError *_Nullable error) {
          callback(wrapResult(output, error));
        }];
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.StyleManager.getStyleTransition"
        binaryMessenger:binaryMessenger
        codec:FLTStyleManagerGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(getStyleTransitionWithCompletion:)], @"FLTStyleManager api (%@) doesn't respond to @selector(getStyleTransitionWithCompletion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        [api getStyleTransitionWithCompletion:^(FLTTransitionOptions *_Nullable output, FlutterError *_Nullable error) {
          callback(wrapResult(output, error));
        }];
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.StyleManager.setStyleTransition"
        binaryMessenger:binaryMessenger
        codec:FLTStyleManagerGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(setStyleTransitionTransitionOptions:completion:)], @"FLTStyleManager api (%@) doesn't respond to @selector(setStyleTransitionTransitionOptions:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        FLTTransitionOptions *arg_transitionOptions = GetNullableObjectAtIndex(args, 0);
        [api setStyleTransitionTransitionOptions:arg_transitionOptions completion:^(FlutterError *_Nullable error) {
          callback(wrapResult(nil, error));
        }];
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.StyleManager.addStyleLayer"
        binaryMessenger:binaryMessenger
        codec:FLTStyleManagerGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(addStyleLayerProperties:layerPosition:completion:)], @"FLTStyleManager api (%@) doesn't respond to @selector(addStyleLayerProperties:layerPosition:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_properties = GetNullableObjectAtIndex(args, 0);
        FLTLayerPosition *arg_layerPosition = GetNullableObjectAtIndex(args, 1);
        [api addStyleLayerProperties:arg_properties layerPosition:arg_layerPosition completion:^(FlutterError *_Nullable error) {
          callback(wrapResult(nil, error));
        }];
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.StyleManager.addPersistentStyleLayer"
        binaryMessenger:binaryMessenger
        codec:FLTStyleManagerGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(addPersistentStyleLayerProperties:layerPosition:completion:)], @"FLTStyleManager api (%@) doesn't respond to @selector(addPersistentStyleLayerProperties:layerPosition:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_properties = GetNullableObjectAtIndex(args, 0);
        FLTLayerPosition *arg_layerPosition = GetNullableObjectAtIndex(args, 1);
        [api addPersistentStyleLayerProperties:arg_properties layerPosition:arg_layerPosition completion:^(FlutterError *_Nullable error) {
          callback(wrapResult(nil, error));
        }];
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.StyleManager.isStyleLayerPersistent"
        binaryMessenger:binaryMessenger
        codec:FLTStyleManagerGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(isStyleLayerPersistentLayerId:completion:)], @"FLTStyleManager api (%@) doesn't respond to @selector(isStyleLayerPersistentLayerId:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_layerId = GetNullableObjectAtIndex(args, 0);
        [api isStyleLayerPersistentLayerId:arg_layerId completion:^(NSNumber *_Nullable output, FlutterError *_Nullable error) {
          callback(wrapResult(output, error));
        }];
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.StyleManager.removeStyleLayer"
        binaryMessenger:binaryMessenger
        codec:FLTStyleManagerGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(removeStyleLayerLayerId:completion:)], @"FLTStyleManager api (%@) doesn't respond to @selector(removeStyleLayerLayerId:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_layerId = GetNullableObjectAtIndex(args, 0);
        [api removeStyleLayerLayerId:arg_layerId completion:^(FlutterError *_Nullable error) {
          callback(wrapResult(nil, error));
        }];
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.StyleManager.moveStyleLayer"
        binaryMessenger:binaryMessenger
        codec:FLTStyleManagerGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(moveStyleLayerLayerId:layerPosition:completion:)], @"FLTStyleManager api (%@) doesn't respond to @selector(moveStyleLayerLayerId:layerPosition:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_layerId = GetNullableObjectAtIndex(args, 0);
        FLTLayerPosition *arg_layerPosition = GetNullableObjectAtIndex(args, 1);
        [api moveStyleLayerLayerId:arg_layerId layerPosition:arg_layerPosition completion:^(FlutterError *_Nullable error) {
          callback(wrapResult(nil, error));
        }];
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.StyleManager.styleLayerExists"
        binaryMessenger:binaryMessenger
        codec:FLTStyleManagerGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(styleLayerExistsLayerId:completion:)], @"FLTStyleManager api (%@) doesn't respond to @selector(styleLayerExistsLayerId:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_layerId = GetNullableObjectAtIndex(args, 0);
        [api styleLayerExistsLayerId:arg_layerId completion:^(NSNumber *_Nullable output, FlutterError *_Nullable error) {
          callback(wrapResult(output, error));
        }];
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.StyleManager.getStyleLayers"
        binaryMessenger:binaryMessenger
        codec:FLTStyleManagerGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(getStyleLayersWithCompletion:)], @"FLTStyleManager api (%@) doesn't respond to @selector(getStyleLayersWithCompletion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        [api getStyleLayersWithCompletion:^(NSArray<FLTStyleObjectInfo *> *_Nullable output, FlutterError *_Nullable error) {
          callback(wrapResult(output, error));
        }];
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.StyleManager.getStyleLayerProperty"
        binaryMessenger:binaryMessenger
        codec:FLTStyleManagerGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(getStyleLayerPropertyLayerId:property:completion:)], @"FLTStyleManager api (%@) doesn't respond to @selector(getStyleLayerPropertyLayerId:property:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_layerId = GetNullableObjectAtIndex(args, 0);
        NSString *arg_property = GetNullableObjectAtIndex(args, 1);
        [api getStyleLayerPropertyLayerId:arg_layerId property:arg_property completion:^(FLTStylePropertyValue *_Nullable output, FlutterError *_Nullable error) {
          callback(wrapResult(output, error));
        }];
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.StyleManager.setStyleLayerProperty"
        binaryMessenger:binaryMessenger
        codec:FLTStyleManagerGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(setStyleLayerPropertyLayerId:property:value:completion:)], @"FLTStyleManager api (%@) doesn't respond to @selector(setStyleLayerPropertyLayerId:property:value:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_layerId = GetNullableObjectAtIndex(args, 0);
        NSString *arg_property = GetNullableObjectAtIndex(args, 1);
        id arg_value = GetNullableObjectAtIndex(args, 2);
        [api setStyleLayerPropertyLayerId:arg_layerId property:arg_property value:arg_value completion:^(FlutterError *_Nullable error) {
          callback(wrapResult(nil, error));
        }];
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.StyleManager.getStyleLayerProperties"
        binaryMessenger:binaryMessenger
        codec:FLTStyleManagerGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(getStyleLayerPropertiesLayerId:completion:)], @"FLTStyleManager api (%@) doesn't respond to @selector(getStyleLayerPropertiesLayerId:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_layerId = GetNullableObjectAtIndex(args, 0);
        [api getStyleLayerPropertiesLayerId:arg_layerId completion:^(NSString *_Nullable output, FlutterError *_Nullable error) {
          callback(wrapResult(output, error));
        }];
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.StyleManager.setStyleLayerProperties"
        binaryMessenger:binaryMessenger
        codec:FLTStyleManagerGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(setStyleLayerPropertiesLayerId:properties:completion:)], @"FLTStyleManager api (%@) doesn't respond to @selector(setStyleLayerPropertiesLayerId:properties:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_layerId = GetNullableObjectAtIndex(args, 0);
        NSString *arg_properties = GetNullableObjectAtIndex(args, 1);
        [api setStyleLayerPropertiesLayerId:arg_layerId properties:arg_properties completion:^(FlutterError *_Nullable error) {
          callback(wrapResult(nil, error));
        }];
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.StyleManager.addStyleSource"
        binaryMessenger:binaryMessenger
        codec:FLTStyleManagerGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(addStyleSourceSourceId:properties:completion:)], @"FLTStyleManager api (%@) doesn't respond to @selector(addStyleSourceSourceId:properties:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_sourceId = GetNullableObjectAtIndex(args, 0);
        NSString *arg_properties = GetNullableObjectAtIndex(args, 1);
        [api addStyleSourceSourceId:arg_sourceId properties:arg_properties completion:^(FlutterError *_Nullable error) {
          callback(wrapResult(nil, error));
        }];
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.StyleManager.getStyleSourceProperty"
        binaryMessenger:binaryMessenger
        codec:FLTStyleManagerGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(getStyleSourcePropertySourceId:property:completion:)], @"FLTStyleManager api (%@) doesn't respond to @selector(getStyleSourcePropertySourceId:property:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_sourceId = GetNullableObjectAtIndex(args, 0);
        NSString *arg_property = GetNullableObjectAtIndex(args, 1);
        [api getStyleSourcePropertySourceId:arg_sourceId property:arg_property completion:^(FLTStylePropertyValue *_Nullable output, FlutterError *_Nullable error) {
          callback(wrapResult(output, error));
        }];
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.StyleManager.setStyleSourceProperty"
        binaryMessenger:binaryMessenger
        codec:FLTStyleManagerGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(setStyleSourcePropertySourceId:property:value:completion:)], @"FLTStyleManager api (%@) doesn't respond to @selector(setStyleSourcePropertySourceId:property:value:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_sourceId = GetNullableObjectAtIndex(args, 0);
        NSString *arg_property = GetNullableObjectAtIndex(args, 1);
        id arg_value = GetNullableObjectAtIndex(args, 2);
        [api setStyleSourcePropertySourceId:arg_sourceId property:arg_property value:arg_value completion:^(FlutterError *_Nullable error) {
          callback(wrapResult(nil, error));
        }];
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.StyleManager.getStyleSourceProperties"
        binaryMessenger:binaryMessenger
        codec:FLTStyleManagerGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(getStyleSourcePropertiesSourceId:completion:)], @"FLTStyleManager api (%@) doesn't respond to @selector(getStyleSourcePropertiesSourceId:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_sourceId = GetNullableObjectAtIndex(args, 0);
        [api getStyleSourcePropertiesSourceId:arg_sourceId completion:^(NSString *_Nullable output, FlutterError *_Nullable error) {
          callback(wrapResult(output, error));
        }];
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.StyleManager.setStyleSourceProperties"
        binaryMessenger:binaryMessenger
        codec:FLTStyleManagerGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(setStyleSourcePropertiesSourceId:properties:completion:)], @"FLTStyleManager api (%@) doesn't respond to @selector(setStyleSourcePropertiesSourceId:properties:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_sourceId = GetNullableObjectAtIndex(args, 0);
        NSString *arg_properties = GetNullableObjectAtIndex(args, 1);
        [api setStyleSourcePropertiesSourceId:arg_sourceId properties:arg_properties completion:^(FlutterError *_Nullable error) {
          callback(wrapResult(nil, error));
        }];
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.StyleManager.updateStyleImageSourceImage"
        binaryMessenger:binaryMessenger
        codec:FLTStyleManagerGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(updateStyleImageSourceImageSourceId:image:completion:)], @"FLTStyleManager api (%@) doesn't respond to @selector(updateStyleImageSourceImageSourceId:image:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_sourceId = GetNullableObjectAtIndex(args, 0);
        FLTMbxImage *arg_image = GetNullableObjectAtIndex(args, 1);
        [api updateStyleImageSourceImageSourceId:arg_sourceId image:arg_image completion:^(FlutterError *_Nullable error) {
          callback(wrapResult(nil, error));
        }];
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.StyleManager.removeStyleSource"
        binaryMessenger:binaryMessenger
        codec:FLTStyleManagerGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(removeStyleSourceSourceId:completion:)], @"FLTStyleManager api (%@) doesn't respond to @selector(removeStyleSourceSourceId:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_sourceId = GetNullableObjectAtIndex(args, 0);
        [api removeStyleSourceSourceId:arg_sourceId completion:^(FlutterError *_Nullable error) {
          callback(wrapResult(nil, error));
        }];
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.StyleManager.styleSourceExists"
        binaryMessenger:binaryMessenger
        codec:FLTStyleManagerGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(styleSourceExistsSourceId:completion:)], @"FLTStyleManager api (%@) doesn't respond to @selector(styleSourceExistsSourceId:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_sourceId = GetNullableObjectAtIndex(args, 0);
        [api styleSourceExistsSourceId:arg_sourceId completion:^(NSNumber *_Nullable output, FlutterError *_Nullable error) {
          callback(wrapResult(output, error));
        }];
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.StyleManager.getStyleSources"
        binaryMessenger:binaryMessenger
        codec:FLTStyleManagerGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(getStyleSourcesWithCompletion:)], @"FLTStyleManager api (%@) doesn't respond to @selector(getStyleSourcesWithCompletion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        [api getStyleSourcesWithCompletion:^(NSArray<FLTStyleObjectInfo *> *_Nullable output, FlutterError *_Nullable error) {
          callback(wrapResult(output, error));
        }];
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.StyleManager.setStyleLight"
        binaryMessenger:binaryMessenger
        codec:FLTStyleManagerGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(setStyleLightProperties:completion:)], @"FLTStyleManager api (%@) doesn't respond to @selector(setStyleLightProperties:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_properties = GetNullableObjectAtIndex(args, 0);
        [api setStyleLightProperties:arg_properties completion:^(FlutterError *_Nullable error) {
          callback(wrapResult(nil, error));
        }];
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.StyleManager.getStyleLightProperty"
        binaryMessenger:binaryMessenger
        codec:FLTStyleManagerGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(getStyleLightPropertyProperty:completion:)], @"FLTStyleManager api (%@) doesn't respond to @selector(getStyleLightPropertyProperty:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_property = GetNullableObjectAtIndex(args, 0);
        [api getStyleLightPropertyProperty:arg_property completion:^(FLTStylePropertyValue *_Nullable output, FlutterError *_Nullable error) {
          callback(wrapResult(output, error));
        }];
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.StyleManager.setStyleLightProperty"
        binaryMessenger:binaryMessenger
        codec:FLTStyleManagerGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(setStyleLightPropertyProperty:value:completion:)], @"FLTStyleManager api (%@) doesn't respond to @selector(setStyleLightPropertyProperty:value:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_property = GetNullableObjectAtIndex(args, 0);
        id arg_value = GetNullableObjectAtIndex(args, 1);
        [api setStyleLightPropertyProperty:arg_property value:arg_value completion:^(FlutterError *_Nullable error) {
          callback(wrapResult(nil, error));
        }];
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.StyleManager.setStyleTerrain"
        binaryMessenger:binaryMessenger
        codec:FLTStyleManagerGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(setStyleTerrainProperties:completion:)], @"FLTStyleManager api (%@) doesn't respond to @selector(setStyleTerrainProperties:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_properties = GetNullableObjectAtIndex(args, 0);
        [api setStyleTerrainProperties:arg_properties completion:^(FlutterError *_Nullable error) {
          callback(wrapResult(nil, error));
        }];
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.StyleManager.getStyleTerrainProperty"
        binaryMessenger:binaryMessenger
        codec:FLTStyleManagerGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(getStyleTerrainPropertyProperty:completion:)], @"FLTStyleManager api (%@) doesn't respond to @selector(getStyleTerrainPropertyProperty:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_property = GetNullableObjectAtIndex(args, 0);
        [api getStyleTerrainPropertyProperty:arg_property completion:^(FLTStylePropertyValue *_Nullable output, FlutterError *_Nullable error) {
          callback(wrapResult(output, error));
        }];
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.StyleManager.setStyleTerrainProperty"
        binaryMessenger:binaryMessenger
        codec:FLTStyleManagerGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(setStyleTerrainPropertyProperty:value:completion:)], @"FLTStyleManager api (%@) doesn't respond to @selector(setStyleTerrainPropertyProperty:value:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_property = GetNullableObjectAtIndex(args, 0);
        id arg_value = GetNullableObjectAtIndex(args, 1);
        [api setStyleTerrainPropertyProperty:arg_property value:arg_value completion:^(FlutterError *_Nullable error) {
          callback(wrapResult(nil, error));
        }];
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.StyleManager.getStyleImage"
        binaryMessenger:binaryMessenger
        codec:FLTStyleManagerGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(getStyleImageImageId:completion:)], @"FLTStyleManager api (%@) doesn't respond to @selector(getStyleImageImageId:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_imageId = GetNullableObjectAtIndex(args, 0);
        [api getStyleImageImageId:arg_imageId completion:^(FLTMbxImage *_Nullable output, FlutterError *_Nullable error) {
          callback(wrapResult(output, error));
        }];
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.StyleManager.addStyleImage"
        binaryMessenger:binaryMessenger
        codec:FLTStyleManagerGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(addStyleImageImageId:scale:image:sdf:stretchX:stretchY:content:completion:)], @"FLTStyleManager api (%@) doesn't respond to @selector(addStyleImageImageId:scale:image:sdf:stretchX:stretchY:content:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_imageId = GetNullableObjectAtIndex(args, 0);
        NSNumber *arg_scale = GetNullableObjectAtIndex(args, 1);
        FLTMbxImage *arg_image = GetNullableObjectAtIndex(args, 2);
        NSNumber *arg_sdf = GetNullableObjectAtIndex(args, 3);
        NSArray<FLTImageStretches *> *arg_stretchX = GetNullableObjectAtIndex(args, 4);
        NSArray<FLTImageStretches *> *arg_stretchY = GetNullableObjectAtIndex(args, 5);
        FLTImageContent *arg_content = GetNullableObjectAtIndex(args, 6);
        [api addStyleImageImageId:arg_imageId scale:arg_scale image:arg_image sdf:arg_sdf stretchX:arg_stretchX stretchY:arg_stretchY content:arg_content completion:^(FlutterError *_Nullable error) {
          callback(wrapResult(nil, error));
        }];
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.StyleManager.removeStyleImage"
        binaryMessenger:binaryMessenger
        codec:FLTStyleManagerGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(removeStyleImageImageId:completion:)], @"FLTStyleManager api (%@) doesn't respond to @selector(removeStyleImageImageId:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_imageId = GetNullableObjectAtIndex(args, 0);
        [api removeStyleImageImageId:arg_imageId completion:^(FlutterError *_Nullable error) {
          callback(wrapResult(nil, error));
        }];
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.StyleManager.hasStyleImage"
        binaryMessenger:binaryMessenger
        codec:FLTStyleManagerGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(hasStyleImageImageId:completion:)], @"FLTStyleManager api (%@) doesn't respond to @selector(hasStyleImageImageId:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_imageId = GetNullableObjectAtIndex(args, 0);
        [api hasStyleImageImageId:arg_imageId completion:^(NSNumber *_Nullable output, FlutterError *_Nullable error) {
          callback(wrapResult(output, error));
        }];
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.StyleManager.invalidateStyleCustomGeometrySourceTile"
        binaryMessenger:binaryMessenger
        codec:FLTStyleManagerGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(invalidateStyleCustomGeometrySourceTileSourceId:tileId:completion:)], @"FLTStyleManager api (%@) doesn't respond to @selector(invalidateStyleCustomGeometrySourceTileSourceId:tileId:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_sourceId = GetNullableObjectAtIndex(args, 0);
        FLTCanonicalTileID *arg_tileId = GetNullableObjectAtIndex(args, 1);
        [api invalidateStyleCustomGeometrySourceTileSourceId:arg_sourceId tileId:arg_tileId completion:^(FlutterError *_Nullable error) {
          callback(wrapResult(nil, error));
        }];
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.StyleManager.invalidateStyleCustomGeometrySourceRegion"
        binaryMessenger:binaryMessenger
        codec:FLTStyleManagerGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(invalidateStyleCustomGeometrySourceRegionSourceId:bounds:completion:)], @"FLTStyleManager api (%@) doesn't respond to @selector(invalidateStyleCustomGeometrySourceRegionSourceId:bounds:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_sourceId = GetNullableObjectAtIndex(args, 0);
        FLTCoordinateBounds *arg_bounds = GetNullableObjectAtIndex(args, 1);
        [api invalidateStyleCustomGeometrySourceRegionSourceId:arg_sourceId bounds:arg_bounds completion:^(FlutterError *_Nullable error) {
          callback(wrapResult(nil, error));
        }];
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.StyleManager.isStyleLoaded"
        binaryMessenger:binaryMessenger
        codec:FLTStyleManagerGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(isStyleLoadedWithCompletion:)], @"FLTStyleManager api (%@) doesn't respond to @selector(isStyleLoadedWithCompletion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        [api isStyleLoadedWithCompletion:^(NSNumber *_Nullable output, FlutterError *_Nullable error) {
          callback(wrapResult(output, error));
        }];
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.StyleManager.getProjection"
        binaryMessenger:binaryMessenger
        codec:FLTStyleManagerGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(getProjectionWithCompletion:)], @"FLTStyleManager api (%@) doesn't respond to @selector(getProjectionWithCompletion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        [api getProjectionWithCompletion:^(NSString *_Nullable output, FlutterError *_Nullable error) {
          callback(wrapResult(output, error));
        }];
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.StyleManager.setProjection"
        binaryMessenger:binaryMessenger
        codec:FLTStyleManagerGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(setProjectionProjection:completion:)], @"FLTStyleManager api (%@) doesn't respond to @selector(setProjectionProjection:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_projection = GetNullableObjectAtIndex(args, 0);
        [api setProjectionProjection:arg_projection completion:^(FlutterError *_Nullable error) {
          callback(wrapResult(nil, error));
        }];
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
}
@interface FLTCancelableCodecReader : FlutterStandardReader
@end
@implementation FLTCancelableCodecReader
@end

@interface FLTCancelableCodecWriter : FlutterStandardWriter
@end
@implementation FLTCancelableCodecWriter
@end

@interface FLTCancelableCodecReaderWriter : FlutterStandardReaderWriter
@end
@implementation FLTCancelableCodecReaderWriter
- (FlutterStandardWriter *)writerWithData:(NSMutableData *)data {
  return [[FLTCancelableCodecWriter alloc] initWithData:data];
}
- (FlutterStandardReader *)readerWithData:(NSData *)data {
  return [[FLTCancelableCodecReader alloc] initWithData:data];
}
@end

NSObject<FlutterMessageCodec> *FLTCancelableGetCodec() {
  static dispatch_once_t sPred = 0;
  static FlutterStandardMessageCodec *sSharedObject = nil;
  dispatch_once(&sPred, ^{
    FLTCancelableCodecReaderWriter *readerWriter = [[FLTCancelableCodecReaderWriter alloc] init];
    sSharedObject = [FlutterStandardMessageCodec codecWithReaderWriter:readerWriter];
  });
  return sSharedObject;
}


void FLTCancelableSetup(id<FlutterBinaryMessenger> binaryMessenger, NSObject<FLTCancelable> *api) {
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.Cancelable.cancel"
        binaryMessenger:binaryMessenger
        codec:FLTCancelableGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(cancelWithError:)], @"FLTCancelable api (%@) doesn't respond to @selector(cancelWithError:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        [api cancelWithError:&error];
        callback(wrapResult(nil, error));
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
}
@interface FLTOfflineSwitchCodecReader : FlutterStandardReader
@end
@implementation FLTOfflineSwitchCodecReader
@end

@interface FLTOfflineSwitchCodecWriter : FlutterStandardWriter
@end
@implementation FLTOfflineSwitchCodecWriter
@end

@interface FLTOfflineSwitchCodecReaderWriter : FlutterStandardReaderWriter
@end
@implementation FLTOfflineSwitchCodecReaderWriter
- (FlutterStandardWriter *)writerWithData:(NSMutableData *)data {
  return [[FLTOfflineSwitchCodecWriter alloc] initWithData:data];
}
- (FlutterStandardReader *)readerWithData:(NSData *)data {
  return [[FLTOfflineSwitchCodecReader alloc] initWithData:data];
}
@end

NSObject<FlutterMessageCodec> *FLTOfflineSwitchGetCodec() {
  static dispatch_once_t sPred = 0;
  static FlutterStandardMessageCodec *sSharedObject = nil;
  dispatch_once(&sPred, ^{
    FLTOfflineSwitchCodecReaderWriter *readerWriter = [[FLTOfflineSwitchCodecReaderWriter alloc] init];
    sSharedObject = [FlutterStandardMessageCodec codecWithReaderWriter:readerWriter];
  });
  return sSharedObject;
}


void FLTOfflineSwitchSetup(id<FlutterBinaryMessenger> binaryMessenger, NSObject<FLTOfflineSwitch> *api) {
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.OfflineSwitch.setMapboxStackConnected"
        binaryMessenger:binaryMessenger
        codec:FLTOfflineSwitchGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(setMapboxStackConnectedConnected:error:)], @"FLTOfflineSwitch api (%@) doesn't respond to @selector(setMapboxStackConnectedConnected:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSNumber *arg_connected = GetNullableObjectAtIndex(args, 0);
        FlutterError *error;
        [api setMapboxStackConnectedConnected:arg_connected error:&error];
        callback(wrapResult(nil, error));
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.OfflineSwitch.isMapboxStackConnected"
        binaryMessenger:binaryMessenger
        codec:FLTOfflineSwitchGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(isMapboxStackConnectedWithError:)], @"FLTOfflineSwitch api (%@) doesn't respond to @selector(isMapboxStackConnectedWithError:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        NSNumber *output = [api isMapboxStackConnectedWithError:&error];
        callback(wrapResult(output, error));
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.OfflineSwitch.reset"
        binaryMessenger:binaryMessenger
        codec:FLTOfflineSwitchGetCodec()        ];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(resetWithError:)], @"FLTOfflineSwitch api (%@) doesn't respond to @selector(resetWithError:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        [api resetWithError:&error];
        callback(wrapResult(nil, error));
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
}
@interface FLTTilesetDescriptorCodecReader : FlutterStandardReader
@end
@implementation FLTTilesetDescriptorCodecReader
@end

@interface FLTTilesetDescriptorCodecWriter : FlutterStandardWriter
@end
@implementation FLTTilesetDescriptorCodecWriter
@end

@interface FLTTilesetDescriptorCodecReaderWriter : FlutterStandardReaderWriter
@end
@implementation FLTTilesetDescriptorCodecReaderWriter
- (FlutterStandardWriter *)writerWithData:(NSMutableData *)data {
  return [[FLTTilesetDescriptorCodecWriter alloc] initWithData:data];
}
- (FlutterStandardReader *)readerWithData:(NSData *)data {
  return [[FLTTilesetDescriptorCodecReader alloc] initWithData:data];
}
@end

NSObject<FlutterMessageCodec> *FLTTilesetDescriptorGetCodec() {
  static dispatch_once_t sPred = 0;
  static FlutterStandardMessageCodec *sSharedObject = nil;
  dispatch_once(&sPred, ^{
    FLTTilesetDescriptorCodecReaderWriter *readerWriter = [[FLTTilesetDescriptorCodecReaderWriter alloc] init];
    sSharedObject = [FlutterStandardMessageCodec codecWithReaderWriter:readerWriter];
  });
  return sSharedObject;
}


void FLTTilesetDescriptorSetup(id<FlutterBinaryMessenger> binaryMessenger, NSObject<FLTTilesetDescriptor> *api) {
}
